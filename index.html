<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>핵앤슬래시 갸챠 게임 v23.0 (콘텐츠 확장 및 밸런스 개편)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --panel-bg: rgba(10, 10, 25, 0.95);
            --border-gradient: linear-gradient(to right, #b8860b, #ffd700, #b8860b);
            --font-color: #ecf0f1;
            --primary-color: #3498db;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --warn-color: #f1c40f;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Noto Sans KR', 'Arial', sans-serif; background: #1a1a1a; color: var(--font-color); overflow: hidden; display: flex; align-items: center; justify-content: center; height: 100vh; }
        #gameContainer { width: 1280px; height: 720px; position: relative; background-color: #000; box-shadow: 0 0 40px rgba(74, 144, 226, 0.4); border-radius: 10px; overflow: hidden; }
        #gameCanvas { background: linear-gradient(to bottom, #2c3e50, #34495e); display: block; width: 100%; height: 100%; cursor: crosshair; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; }
        .ui-panel { position: absolute; background: var(--panel-bg); border: 3px solid; border-image-slice: 1; border-image-source: var(--border-gradient); padding: 15px; pointer-events: auto; backdrop-filter: blur(10px); font-size: 14px; border-radius: 8px; }
        #statsPanel { top: 20px; left: 20px; width: 300px; }
        #equipmentPanel { top: 20px; right: 20px; width: 300px; }
        #inventoryPanel, #gachaPanel, #talentPanel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 900px; max-height: 85vh; display: none; z-index: 21; overflow-y: auto; }
        #bottomUIPanel { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 500px; text-align: center; pointer-events: auto; }
        #modal-backdrop { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; z-index: 200; align-items: center; justify-content: center;}
        .modal { text-align: center; background: var(--panel-bg); padding: 40px; border-radius: 15px; border: 3px solid; border-image-slice: 1; border-image-source: var(--border-gradient); }
        .button { background: var(--primary-color); border: 2px solid #fff; color: white; padding: 10px 18px; margin: 6px; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.3s; font-family: 'Noto Sans KR', sans-serif; }
        .button:hover { filter: brightness(1.3); transform: translateY(-2px); box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4); }
        .button:disabled { background: #555; cursor: not-allowed; transform: none; }
        .item { margin: 8px 0; padding: 12px; border-left: 5px solid; cursor: pointer; transition: all 0.3s; background: rgba(255, 255, 255, 0.08); display: flex; justify-content: space-between; align-items: center; border-radius: 6px; }
        .item:hover { background: rgba(255, 255, 255, 0.12); transform: translateX(5px); }
        .item.equipped { background: linear-gradient(90deg, rgba(46, 204, 113, 0.3), transparent) !important; border: 2px solid var(--success-color); }
        .progress-bar { width: 100%; height: 14px; background: #333; border-radius: 8px; overflow: hidden; margin: 10px 0; border: 2px solid #555; }
        .progress-fill { height: 100%; transition: width 0.6s ease; }
        #expBar { background: linear-gradient(90deg, #27ae60, #f1c40f, #e67e22); }
        #hpBar { background: linear-gradient(90deg, #c0392b, #e74c3c, #ff6b6b); }
        .equipment-area { cursor: pointer; padding: 5px; margin-bottom: 10px; border-radius: 5px; transition: background-color 0.3s; }
        .equipment-area:hover { background-color: rgba(255,255,255,0.1); }
        .equipment-slot, .skill-slot { display: inline-flex; align-items: center; justify-content: center; width: 70px; height: 70px; border: 3px dashed #666; margin: 6px; background: rgba(0, 0, 0, 0.6); text-align: center; font-size: 11px; cursor: pointer; transition: all 0.4s; position: relative; padding: 8px; overflow: hidden; word-wrap: break-word; border-radius: 10px; }
        .equipment-slot.filled, .skill-slot.filled { border-style: solid; background: rgba(255, 255, 255, 0.1); }
        .equipment-slot:hover, .skill-slot:hover { transform: scale(1.05); border-color: var(--primary-color); }
        .cooldown-overlay { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0,0,0,0.8); transition: height 0.1s linear; pointer-events: none; border-radius: 0 0 7px 7px; }
        .skill-ready { animation: skillPulse 1.5s infinite; }
        @keyframes skillPulse { 0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.8); } 70% { box-shadow: 0 0 0 15px rgba(46, 204, 113, 0); } 100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); } }
        h3 { color: var(--warn-color); margin-bottom: 15px; font-size: 18px; border-bottom: 2px solid; border-image: var(--border-gradient) 1; padding-bottom: 8px; text-transform: uppercase; font-weight: 700; }
        .stat-row { margin: 8px 0; display: flex; justify-content: space-between; font-weight: 500; }
        .stat-value { color: var(--warn-color); font-weight: 700; }
        .damage-text { position: absolute; font-weight: bold; pointer-events: none; animation: floatUp 2s ease-out forwards; text-shadow: 2px 2px 4px #000; font-size: 18px; }
        @keyframes floatUp { to { transform: translateY(-100px); opacity: 0; } }
        #notification-area { position: absolute; top: 30px; left: 50%; transform: translateX(-50%); z-index: 1000; display: flex; flex-direction: column; align-items: center; gap: 12px; }
        .notification { padding: 12px 25px; background: rgba(0,0,0,0.9); border-radius: 8px; animation: notificationSlide 4s forwards; border: 2px solid var(--primary-color); font-weight: 600; }
        @keyframes notificationSlide { 0% { opacity: 0; transform: translateY(-30px); } 10%, 80% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-30px); } }
        #gachaResultContent { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; }
        .gacha-card { width: 140px; height: 200px; perspective: 1000px; }
        .gacha-card-inner { position: relative; width: 100%; height: 100%; transition: transform 0.8s; transform-style: preserve-3d; }
        .gacha-card.is-flipped .gacha-card-inner { transform: rotateY(180deg); }
        .gacha-card-front, .gacha-card-back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 15px; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 12px; border: 3px solid #ffd700; }
        .gacha-card-front { background: linear-gradient(45deg, #6a82fb, #fc5c7d); }
        .gacha-card-back { transform: rotateY(180deg); }
        #talentPanel { width: 1100px; }
        #talent-container { display: flex; flex-direction: column; gap: 15px; }
        .talent-tree { display: flex; align-items: center; padding: 10px; border: 2px solid #555; border-radius: 8px; }
        .talent-tree-name { font-size: 16px; font-weight: bold; color: var(--primary-color); width: 120px; text-align: center; flex-shrink: 0; }
        .talent-nodes-container { display: flex; align-items: center; overflow-x: auto; }
        .talent-node-wrapper { display: flex; align-items: center; }
        .talent-node { width: 100px; height: 100px; border: 3px solid #666; border-radius: 15px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.4s; background: rgba(0,0,0,0.8); font-size: 11px; text-align: center; padding: 5px; position: relative; flex-shrink: 0;}
        .talent-connector { width: 30px; height: 5px; background-color: #666; }
        .talent-node.unlocked { border-color: var(--success-color); background: rgba(46, 204, 113, 0.3); transform: scale(1.05); }
        .talent-node.unlocked + .talent-connector { background-color: var(--success-color); }
        .talent-node.available { border-color: var(--warn-color); animation: talentGlow 2s infinite; }
        .talent-node-name { font-weight: bold; font-size: 12px; }
        .talent-node-desc { font-size: 9px; margin: 3px 0; }
        .talent-node-cost { font-size: 9px; color: #f1c40f; }
        @keyframes talentGlow { 0%, 100% { box-shadow: 0 0 8px var(--warn-color); } 50% { box-shadow: 0 0 25px var(--warn-color); } }
        .floor-display { font-size: 20px; font-weight: 700; color: var(--warn-color); text-shadow: 0 0 10px var(--warn-color); }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="statsPanel" class="ui-panel">
                <h3>플레이어 정보</h3>
                <div class="stat-row"><span>레벨:</span><span class="stat-value" id="playerLevel">1</span></div>
                <div class="stat-row"><span>경험치:</span><span><span class="stat-value" id="playerExp">0</span> / <span id="expToNext">100</span></span></div>
                <div class="progress-bar"><div id="expBar" class="progress-fill"></div></div>
                <div class="stat-row"><span>체력:</span><span><span class="stat-value" id="playerHP">100</span> / <span id="playerMaxHP">100</span></span></div>
                <div class="progress-bar"><div id="hpBar" class="progress-fill"></div></div>
                <div class="stat-row"><span>공격력:</span><span class="stat-value" id="playerAttack">5</span></div>
                <div class="stat-row"><span>공격속도:</span><span class="stat-value" id="playerAttackSpeed">1.0</span></div>
                <div class="stat-row"><span>방어력:</span><span class="stat-value" id="playerDefense">0</span></div>
                <div class="stat-row"><span>골드:</span><span class="stat-value" id="playerGold">1000</span></div>
                <div class="stat-row"><span>토큰:</span><span class="stat-value" id="gachaTokens">100</span></div>
                <div class="stat-row"><span>특성 포인트:</span><span class="stat-value" id="talentPoints">0</span></div>
                <div class="stat-row floor-display"><span>층수:</span><span><span id="currentFloor">1</span>-<span id="currentWave">1</span></span></div>
            </div>
            
            <div id="equipmentPanel" class="ui-panel">
                <h3>장비</h3>
                <div id="weaponArea" class="equipment-area">
                    <span>무기: </span>
                    <div class="equipment-slot" id="weaponSlot">맨손</div>
                </div>
                <div id="armorArea" class="equipment-area">
                    <span>방어구: </span>
                    <div class="equipment-slot" id="armorSlot">없음</div>
                </div>
                <h3 style="margin-top:20px;">스킬 (1,2,3,4)</h3>
                <div id="skillSlots">
                    <div class="skill-slot" id="skillSlot0" onclick="game.startSkillEquip(0)">
                        <div class="cooldown-overlay"></div>
                        <div style="font-size: 9px;">빈 슬롯</div>
                    </div>
                    <div class="skill-slot" id="skillSlot1" onclick="game.startSkillEquip(1)">
                        <div class="cooldown-overlay"></div>
                        <div style="font-size: 9px;">빈 슬롯</div>
                    </div>
                    <div class="skill-slot" id="skillSlot2" onclick="game.startSkillEquip(2)">
                        <div class="cooldown-overlay"></div>
                        <div style="font-size: 9px;">빈 슬롯</div>
                    </div>
                    <div class="skill-slot" id="skillSlot3" onclick="game.startSkillEquip(3)">
                        <div class="cooldown-overlay"></div>
                        <div style="font-size: 9px;">빈 슬롯</div>
                    </div>
                </div>
            </div>
            
            <div id="inventoryPanel" class="ui-panel">
                <h3>인벤토리 <button id="closeInventoryButton" class="button" style="float:right; padding: 4px 12px;">닫기</button></h3>
                <div id="inventoryFilter">
                    <button class="button" data-filter="all">전체</button>
                    <button class="button" data-filter="weapon">무기</button>
                    <button class="button" data-filter="armor">방어구</button>
                    <button class="button" data-filter="skill">스킬</button>
                </div>
                <div id="inventoryList" style="margin-top: 15px; height: 450px; overflow-y: auto;"></div>
            </div>
            
            <div id="gachaPanel" class="ui-panel">
                <h3>갸챠 <button id="closeGachaButton" class="button" style="float:right; padding: 4px 12px;">닫기</button></h3>
                <div style="margin-bottom: 15px;">천장 카운터 (SSR+): <span class="stat-value" id="pityCounter">100</span></div>
                <div id="gachaResultContent"></div>
                <div style="margin-top: 20px;">
                    <button class="button" id="gacha1Button">1회 뽑기 (10토큰)</button>
                    <button class="button" id="gacha10Button">10회 뽑기 (90토큰)</button>
                </div>
            </div>
            
            <div id="talentPanel" class="ui-panel">
                <h3>특성 트리 <button id="closeTalentButton" class="button" style="float:right; padding: 4px 12px;">닫기</button></h3>
                <p style="margin-bottom: 15px;">사용 가능한 포인트: <span class="stat-value" id="availableTalentPoints">0</span></p>
                <div id="talent-container"></div>
            </div>
            
            <div id="bottomUIPanel">
                <button class="button" id="openGachaButton">갸챠</button>
                <button class="button" id="openTalentButton">특성</button>
                <button class="button" id="openInventoryButton">인벤토리</button>
            </div>
        </div>
        
        <div id="modal-backdrop">
            <div id="floorInfo" class="modal" style="display:none;">
                <h2>층 클리어!</h2>
                <p id="floorReward"></p>
                <button class="button" id="nextFloorButton">다음 층</button>
            </div>
            <div id="gameOverScreen" class="modal" style="display:none;">
                <h2>게임 오버</h2>
                <p>최종 층수: <span class="stat-value" id="finalFloor">1</span></p>
                <button class="button" id="restartButton">다시 시작</button>
            </div>
        </div>
        <div id="notification-area"></div>
    </div>

<script>
// ==================================
// 데이터 정의 (v23.0)
// ==================================
const RARITY_DATA = {
    N:   {r: 0.4599999, c:'#95a5a6', p:1.0}, E:   {r: 0.2500000, c:'#2ecc71', p:1.8}, 
    R:   {r: 0.1500000, c:'#3498db', p:3.2}, S:   {r: 0.0800000, c:'#9b59b6', p:5.8},
    SSR: {r: 0.0070000, c:'#f1c40f', p:15.0}, UR:  {r: 0.0020000, c:'#e67e22', p:30.0},
    L:   {r: 0.0008000, c:'#e74c3c', p:60.0}, U:   {r: 0.0001000, c:'#ff1493', p:120.0},
    SU:  {r: 0.0000500, c:'#00ffff', p:240.0}, SSU: {r: 0.0000300, c:'#adff2f', p:480.0},
    M:   {r: 0.0000100, c:'#ffdead', p:960.0}, LM:  {r: 0.0000080, c:'#f0e68c', p:1920.0},
    EN:  {r: 0.0000020, c:'#dda0dd', p:3840.0}, G:   {r: 0.0000001, c:'#ffffff', p:7680.0}
};

const SSR_WEAPON_SPECIALS = [
    '흡혈 10%', '처치 시 폭발', '연쇄 번개', '방어력 무시 15%', '치명타 시 출혈', 
    '공격 시 공속 증가', '골드 획득량 20% 증가', '빙결 확률 5%', '화상 확률 5%', '스킬 쿨감 1초'
];

// [밸런스 조정] 비관통 무기 추가 버프
const WEAPON_DATA = {
    '맨손':  {t:'p', r:50,  d:0.8, s:2.5, p:0, e:{type:'rect',w:50,h:20,c:'rgba(255,255,255,0.4)'}},
    '단검':  {t:'h', r:80,  d:1.1, s:3, p:0, e:{type:'rect',w:90,h:12,c:'rgba(180,180,180,0.7)'}},
    '검':    {t:'s', r:140, d:2.3, s:1.0, p:0, e:{type:'arc',c:'rgba(200,200,255,0.8)'}},
    '창':    {t:'h', r:160, d:2.0, s:0.5, p:1, e:{type:'rect',w:170,h:15,c:'rgba(220,220,180,0.7)'}},
    '도끼':  {t:'m', r:130, d:2.8, s:0.3, p:1, e:{type:'arc',c:'rgba(255,100,100,0.8)'}},
    '망치':  {t:'m', r:150, d:3.6, s:0.25,p:0, e:{type:'arc',c:'rgba(150,150,150,0.8)'}},
    '활':    {t:'r', v:18,  d:2.0, s:1.1, p:0, life:1000, e:{c:'#f1c40f'}},
    '석궁':  {t:'r', v:16,  d:1.4, s:0.2, p:1, life:1200, e:{c:'#e67e22'}},
    '지팡이':{t:'g', v:10,  d:1.2, s:0.5, p:1, life:1500, e:{count:3,spread:0.15,c:'#9b59b6'}},
    '철퇴':  {t:'m', r:130, d:3.3, s:0.28, p:1, e:{type:'arc',c:'rgba(192,192,192,0.8)'}},
    '카타르':{t:'h', r:90,  d:1.4, s:2.4, p:0, e:{type:'rect',w:100,h:15,c:'rgba(120,200,200,0.7)'}},
    '장궁':  {t:'r', v:22,  d:3.5, s:0.85,p:0, life:1500, e:{c:'#3498db'}},
    '마법총':{t:'g', r: 100, v:20,  d:0.3, s:10, p:0, life:900, e:{count:1,c:'#e74c3c'}},
    '글레이브':{t:'s', r:180, d:1, s:0.6, p:1, e:{type:'arc',c:'rgba(46,204,113,0.8)'}},
    '전투 낫':{t:'m', r:160, d:3.0, s:0.27, p:1, e:{type:'arc',c:'rgba(142,68,173,0.8)'}}
};

const ARMOR_DATA = { '가죽 갑옷': {}, '사슬 갑옷': {}, '강철 갑옷': {}, '철판 흉갑': {}, '미스릴 갑옷': {}, '용비늘 갑옷': {}, '암흑 갑옷': {}, '수호신의 갑옷': {}, '광휘의 갑옷': {}, '타락한 심장의 갑주': {} };

const SKILL_DATA = {
    '메테오': {type:'aoe', r:120, d:2.5, cd:10, c:'rgba(255,100,0,0.7)', name:'메테오'},
    '연쇄 번개': {type:'chain', t:4, d:0.8, cd:6, c:'rgba(100,100,255,0.8)', name:'연쇄 번개'},
    '칼날 폭풍': {type:'aura', r:180, d:0.3, dur:5, tick:0.25, cd:12, c:'rgba(200,200,200,0.5)', name:'칼날 폭풍'},
    '치유의 빛': {type:'heal', a:0.3, cd:15, c:'rgba(100,255,100,0.8)', name:'치유의 빛'},
    '빙결': {type:'aoe', r:100, d:0.5, cd:8, c:'rgba(100,200,255,0.6)', frz:2, name:'빙결'},
    '독 안개': {type:'aura', r:150, d:0.2, dur:8, tick:0.5, cd:10, c:'rgba(100,255,100,0.4)', name:'독 안개'},
    '보호막': {type:'buff', dur:5, cd:20, val:0.3, name:'보호막'},
    '광폭화': {type:'buff', dur:8, cd:18, val:0.5, name:'광폭화'},
    '흡혈 저주': {type:'aoe_dot', r:100, d:0.2, dur:6, tick:0.5, cd:12, c:'rgba(192,57,43,0.6)', name:'흡혈 저주'},
    '지진': {type:'aoe_slow', r:200, d:1.5, dur:4, cd:15, val:0.5, c:'rgba(139,69,19,0.6)', name:'지진'},
    '눈보라': {type:'aura_freeze', r:200, d:0.1, dur:6, tick:1, cd:20, frz:0.5, c:'rgba(224,255,255,0.5)', name:'눈보라'},
    '암살': {type:'single_target', d:5, cd:8, name:'암살'},
    '신성 폭발': {type:'aoe_heal', r:150, d:1.0, a:0.2, cd:18, c:'rgba(255,215,0,0.6)', name:'신성 폭발'},
    '시간 왜곡': {type:'buff_global', dur:5, cd:30, val:0.5, name:'시간 왜곡'},
    '피의 갈증': {type:'aura_lifesteal', r:180, dur:7, tick:0.2, d:0.25, val:0.1, cd:16, c:'rgba(255,0,0,0.4)', name:'피의 갈증'},
    '천상의 방패': {type:'invincible', dur:3, cd:40, name:'천상의 방패'}
};

// [특성 확장] 각 계열당 8개로 확장
const TALENT_DATA = {
    '공격': { name: '공격', talents: [
        {id:'atk1', name:'기초 훈련', desc:'공격력 +10%', cost:1},
        {id:'atk2', name:'치명상 연구', desc:'치명타 피해 +30%', cost:2, prereq:'atk1'},
        {id:'atk3', name:'약점 포착', desc:'치명타 확률 +5%', cost:2, prereq:'atk2'},
        {id:'atk4', name:'무기 전문가', desc:'모든 무기 피해 +15%', cost:3, prereq:'atk3'},
        {id:'atk5', name:'결정타', desc:'치명타 시 10% 확률로 2배 피해', cost:4, prereq:'atk4'},
        {id:'atk6', name:'파괴자', desc:'공격력 +25%', cost:4, prereq:'atk5'},
        {id:'atk7', name:'학살자', desc:'적 처치 시 5초간 공격력 +20%', cost:5, prereq:'atk6'},
        {id:'atk8', name:'전쟁의 신', desc:'공격력 +20%, 치명타 확률 +10%', cost:6, prereq:'atk7'},
    ]},
    '방어': { name: '방어', talents: [
        {id:'def1', name:'기초 훈련', desc:'최대 체력 +15%', cost:1},
        {id:'def2', name:'강철 피부', desc:'방어력 +20%', cost:2, prereq:'def1'},
        {id:'def3', name:'재생력', desc:'초당 체력 0.5% 재생', cost:3, prereq:'def2'},
        {id:'def4', name:'불굴', desc:'받는 피해 10% 감소', cost:3, prereq:'def3'},
        {id:'def5', name:'강철의 의지', desc:'피격 시 5초간 방어력 +30%', cost:4, prereq:'def4'},
        {id:'def6', name:'회피', desc:'받는 피해 10% 확률로 무시', cost:4, prereq:'def5'},
        {id:'def7', name:'수호자', desc:'최대 체력 +30%, 방어력 +30%', cost:5, prereq:'def6'},
        {id:'def8', name:'불멸자', desc:'받는 피해 15% 감소, 초당 체력 1% 재생', cost:6, prereq:'def7'},
    ]},
    '유틸': { name: '유틸', talents: [
        {id:'util1', name:'신속', desc:'공격 속도 +10%', cost:1},
        {id:'util2', name:'지혜', desc:'경험치 획득량 +20%', cost:2, prereq:'util1'},
        {id:'util3', name:'마력 제어', desc:'스킬 쿨다운 -10%', cost:3, prereq:'util2'},
        {id:'util4', name:'효과 증폭', desc:'스킬 효과(지속,범위) +20%', cost:3, prereq:'util3'},
        {id:'util5', name:'연금술', desc:'물약 및 회복 효과 +25%', cost:4, prereq:'util4'},
        {id:'util6', name:'시간 가속', desc:'공격 속도 +15%, 쿨다운 -15%', cost:4, prereq:'util5'},
        {id:'util7', name:'마력 폭주', desc:'스킬 사용 시 5% 확률로 쿨타임 초기화', cost:5, prereq:'util6'},
        {id:'util8', name:'현자', desc:'모든 스킬 레벨 +1 효과', cost:6, prereq:'util7'},
    ]},
    '탐욕': { name: '탐욕', talents: [
        {id:'greed1', name:'협상가', desc:'골드 획득량 +20%', cost:1},
        {id:'greed2', name:'보물 사냥꾼', desc:'토큰 드롭 확률 +15%', cost:2, prereq:'greed1'},
        {id:'greed3', name:'행운', desc:'상위 등급 아이템 드롭 확률 증가', cost:3, prereq:'greed2'},
        {id:'greed4', name:'황금 손길', desc:'적 처치 시 5% 확률로 10배 골드 획득', cost:3, prereq:'greed3'},
        {id:'greed5', name:'계약', desc:'강화 비용 20% 감소', cost:4, prereq:'greed4'},
        {id:'greed6', name:'약탈', desc:'공격 시 1% 확률로 적에게서 골드 훔침', cost:4, prereq:'greed5'},
        {id:'greed7', name:'탐욕의 왕', desc:'골드/토큰 획득량 +30%', cost:5, prereq:'greed6'},
        {id:'greed8', name:'보물왕', desc:'층 클리어 시 추가 보상 획득', cost:6, prereq:'greed7'},
    ]},
    '특수': { name: '특수', talents: [
        {id:'spec1', name:'흡혈', desc:'주는 피해의 2%만큼 체력 회복', cost:2},
        {id:'spec2', name:'반사', desc:'받는 피해의 10%를 적에게 반사', cost:2, prereq:'spec1'},
        {id:'spec3', name:'죽음의 저항', desc:'죽음에 이르는 피해 시 1회 생존', cost:3, prereq:'spec2'},
        {id:'spec4', name:'처형인', desc:'체력 20% 이하 적에게 피해 +50%', cost:4, prereq:'spec3'},
        {id:'spec5', name:'역병', desc:'공격 시 5초간 적 방어력 10% 감소', cost:4, prereq:'spec4'},
        {id:'spec6', name:'초월', desc:'모든 스탯 +15%', cost:5, prereq:'spec5'},
        {id:'spec7', name:'지배자', desc:'엘리트/보스에게 주는 피해 +25%', cost:5, prereq:'spec6'},
        {id:'spec8', name:'파멸', desc:'모든 피해량 20% 증가, 받는 피해 10% 증가', cost:6, prereq:'spec7'},
    ]}
};

class Particle {
    constructor(x, y, color, size, speed, life) { this.x = x; this.y = y; this.color = color; this.size = size; this.life = life; this.maxLife = life; this.vx = speed * (Math.random() - 0.5) * 2; this.vy = speed * (Math.random() - 0.5) * 2; }
    update(dt) { this.life -= dt; this.x += this.vx * (dt / 1000); this.y += this.vy * (dt / 1000); this.vy += 50 * (dt / 1000); }
    draw(ctx) { ctx.save(); ctx.globalAlpha = this.life / this.maxLife; ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
}
class Enemy {
    constructor(game, isElite) { this.game = game; this.id = Math.random(); this.isElite = isElite; this.x = game.canvas.width + 50 + Math.random() * 200 * (game.currentfloor ** 1/2); this.size = isElite ? 30 : 18; this.y = game.groundY - this.size; const floorMultiplier = Math.pow(1.3, game.currentFloor - 1); this.maxHp = Math.floor((30 + game.currentFloor * 20) * (isElite ? 3.0 : 1) * floorMultiplier); this.hp = this.maxHp; this.damage = Math.floor((12 + game.currentFloor * 3) * (isElite ? 2.2 : 1) * floorMultiplier); this.speed = (70 + game.currentFloor * 15) * (isElite ? 0.9 : 1) * Math.min(floorMultiplier * 0.8, 3); this.lastAttackTime = 0; this.isFrozen = false; this.freezeTimer = 0; }
    update(dt, player, dealDamageCallback) { if (this.isFrozen) { this.freezeTimer -= dt; if (this.freezeTimer <= 0) this.isFrozen = false; return; } const dx = player.x - this.x; if (Math.abs(dx) > this.size) { this.x += Math.sign(dx) * this.speed * (dt / 1000); } if (Math.abs(dx) < this.size + player.size + 10 && Date.now() - this.lastAttackTime > 1800) { this.lastAttackTime = Date.now(); dealDamageCallback(Math.floor(this.damage)); } }
    draw(ctx) { ctx.save(); if (this.isElite) { ctx.shadowBlur = 15; ctx.shadowColor = '#e74c3c'; } ctx.fillStyle = this.isElite ? '#e74c3c' : '#c0392b'; if (this.isFrozen) ctx.fillStyle = '#3498db'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); const bw = 50, bx = this.x - bw / 2, by = this.y - this.size - 15; ctx.fillStyle = '#333'; ctx.fillRect(bx, by, bw, 6); ctx.fillStyle = this.hp > this.maxHp * 0.3 ? '#2ecc71' : '#e74c3c'; ctx.fillRect(bx, by, bw * (this.hp / this.maxHp), 6); if (this.isElite) { ctx.fillStyle = '#ffd700'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('★', this.x, this.y - this.size - 25); } ctx.restore(); }
    takeDamage(d) { this.hp -= d; }
    freeze(dur) { this.isFrozen = true; this.freezeTimer = dur * 1000; }
}
class BaseEffect {
    constructor(g, dur){this.game = g; this.life = dur; this.maxLife = dur; this.isDone = false;}
    update(dt){this.life -= dt; if(this.life <= 0) this.isDone = true;}
    draw(ctx){}
}
class MeleeEffect extends BaseEffect {
    constructor(g, w_item) {
        super(g, 200);
        this.p = g.player; this.w_item = w_item; this.w_data = WEAPON_DATA[w_item.name]; this.hit = new Set();
        this.dmg = this.p.attackPower; const rarityBonus = Object.keys(RARITY_DATA).indexOf(w_item.rarity) * 0.1;
        this.a = { x: this.p.x, y: this.p.y, t: this.w_data.e.type, r: this.w_data.r * (1 + rarityBonus) };
        if (this.a.t === 'rect') { this.a.w = this.w_data.e.w * (1 + rarityBonus); this.a.h = this.w_data.e.h; } 
        else if (this.a.t === 'arc') { this.startAngle = -0.8; this.endAngle = 0.8; }
        this.checkHits();
    }
    checkHits(){
        this.game.enemies.forEach(e => {
            if(this.hit.has(e.id)) return;
            if(this.isColliding(e)){ this.game.dealDamage(e, this.dmg, this.w_item); this.hit.add(e.id); if(!this.w_data.p) this.isDone = true; }
        });
        this.game.particles.push(...Array(15).fill(0).map(() => new Particle(this.p.x + this.a.r / 2, this.p.y, '#fff', Math.random() * 4 + 2, 120, 600)));
    }
    isColliding(e){
        if(this.a.t === 'arc'){ const dx = e.x - this.a.x, dy = e.y - this.a.y; return Math.hypot(dx, dy) < this.a.r + e.size; }
        else if(this.a.t === 'rect'){ const rx = this.a.x + 10, ry = this.a.y - this.a.h / 2; const dx = Math.abs(e.x - rx - this.a.w / 2), dy = Math.abs(e.y - ry - this.a.h / 2); if(dx > this.a.w / 2 + e.size || dy > this.a.h / 2 + e.size) return false; if(dx <= this.a.w / 2 || dy <= this.a.h / 2) return true; return (dx - this.a.w / 2)**2 + (dy - this.a.h / 2)**2 <= e.size**2; }
        return false;
    }
    draw(ctx){
        const prog = 1 - this.life / this.maxLife; ctx.save(); ctx.fillStyle = this.w_data.e.c; ctx.globalAlpha = Math.sin(prog * Math.PI); ctx.shadowBlur = 15; ctx.shadowColor = this.w_data.e.c; ctx.translate(this.p.x, this.p.y);
        if(this.a.t === 'arc'){ const ang = this.startAngle + (this.endAngle - this.startAngle) * prog; ctx.beginPath(); ctx.moveTo(0, 0); ctx.arc(0, 0, this.a.r, this.startAngle, ang); ctx.closePath(); ctx.fill(); }
        else if(this.a.t === 'rect'){ ctx.fillRect(10, -this.a.h / 2, this.a.w, this.a.h); }
        ctx.restore();
    }
}
class SkillEffect extends BaseEffect {
    constructor(g, p, s){
        super(g, s.dur ? s.dur * 1000 : 300);
        this.p = p; this.s = s;  this.x = g.mouse.x; this.y = g.mouse.y; this.dmg = this.p.attackPower * this.s.d; this.tick = 0; this.hit = new Set();
        this.activate();
    }
    activate(){
        switch(this.s.type){
            case 'aoe': this.game.enemies.forEach(e => { if(Math.hypot(this.x - e.x, this.y - e.y) < this.s.r){ this.game.dealDamage(e, this.dmg, null); if(this.s.frz) e.freeze(this.s.frz); } }); this.game.particles.push(...Array(40).fill(0).map(() => new Particle(this.x, this.y, this.s.c, Math.random() * 6 + 3, 250, 1000))); break;
            case 'chain': let t = null; for(let i = 0; i < this.s.t; i++){ const nt = this.findClosest(t ? t.x : this.p.x, t ? t.y : this.p.y); if(nt){ this.game.dealDamage(nt, this.dmg, null); this.hit.add(nt.id); t = nt; } else break; } break;
            case 'heal': const h = this.p.maxHp * this.s.a; this.p.hp = Math.min(this.p.maxHp, this.p.hp + h); this.game.createFloatingText(`+${Math.ceil(h)}`, this.p.x, this.p.y, '100,255,100', 24); break;
        }
    }
    findClosest(x, y, excluded = []){ let c = null, m = Infinity; this.game.enemies.forEach(e => { if(excluded.some(ex => ex && ex.id === e.id) || this.hit.has(e.id)) return; const d = Math.hypot(x - e.x, y - e.y); if(d < m){ m = d; c = e; } }); return c; }
    update(dt){
        super.update(dt);
        if(['aura', 'aura_freeze', 'aura_lifesteal'].includes(this.s.type)){ this.tick -= dt; if(this.tick <= 0){ this.tick = this.s.tick * 1000; this.game.enemies.forEach(e => { if(Math.hypot(this.p.x - e.x, this.p.y - e.y) < this.s.r){ this.game.dealDamage(e, this.p.attackPower * this.s.d, null); if(this.s.type === 'aura_freeze' && this.s.frz) e.freeze(this.s.frz); if(this.s.type === 'aura_lifesteal') { const leech = Math.ceil(this.p.attackPower * this.s.d * this.s.val); this.p.hp = Math.min(this.p.maxHp, this.p.hp + leech); } } }); } }
    }
    draw(ctx){
        ctx.save(); ctx.globalAlpha = Math.max(0, this.life / this.maxLife); ctx.fillStyle = this.s.c; ctx.shadowBlur = 20; ctx.shadowColor = this.s.c;
        if(this.s.type.includes('aoe') || this.s.type.includes('aura')){ const x = this.s.type.includes('aura') ? this.p.x : this.x; const y = this.s.type.includes('aura') ? this.p.y : this.y; ctx.beginPath(); ctx.arc(x, y, this.s.r, 0, Math.PI * 2); ctx.fill(); }
        ctx.restore();
    }
}

class Game {
    constructor(){ this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d'); this.init(); }
    init(isRestart = false){
        this.isGameOver = false; this.canvas.width = 1280; this.canvas.height = 720; this.groundY = this.canvas.height - 80;
        this.resetPlayerState();
        this.enemies = []; this.projectiles = []; this.activeEffects = []; this.floatingTexts = []; this.particles = [];
        this.currentFloor = 1; this.currentWave = 1; this.totalWaves = 5; this.inventoryFilter = 'all'; this.floorCompleted = false;
        this.pityCounter = 100; this.keys = {}; this.mouse = {x:0, y:0, isDown:false}; this.lastAttackTime = 0; this.skillEquipSlot = -1;
        ['inventoryPanel', 'gachaPanel', 'talentPanel'].forEach(id => document.getElementById(id).style.display = 'none');
        this.closeModal('gameOverScreen');
        if (!this.eventListenersAttached) { this.setupEventListeners(); this.eventListenersAttached = true; }
        if (!isRestart) { this.loadGame(); }
        document.getElementById('ui').style.display = 'block';
        this.spawnWave(); this.updateStats(); this.updateUI(); this.initTalentTree();
        if (!this.gameLoopRunning || isRestart) { this.lastFrameTime = performance.now(); this.gameLoop(); }
    }
    resetPlayerState(){
        this.player = { x: 200, y: this.canvas.height - 80 - 20, size: 20, hp: 100, maxHp: 100, defense: 0, level: 1, exp: 0, expToNext: 100, gold: 1000, gachaTokens: 200, baseAttackPower: 5, attackPower: 5, skillCooldowns: [0, 0, 0, 0] };
        this.equipment = {weapon: null, armor: null, skills: [null, null, null, null]}; this.inventory = []; this.talents = {}; this.talentPoints = 0;
    }
    setupEventListeners(){
        const kh = (e, v) => { this.keys[e.key.toLowerCase()] = v; if(v && e.key >= '1' && e.key <= '4') this.useSkill(parseInt(e.key) - 1); };
        window.addEventListener('keydown', e => kh(e, true)); window.addEventListener('keyup', e => kh(e, false));
        this.canvas.addEventListener('mousemove', e => { const r = this.canvas.getBoundingClientRect(); this.mouse.x = e.clientX - r.left; this.mouse.y = e.clientY - r.top; });
        this.canvas.addEventListener('mousedown', () => { this.mouse.isDown = true; }); this.canvas.addEventListener('mouseup', () => { this.mouse.isDown = false; });
        this.canvas.addEventListener('click', () => this.attack());
        const buttons = { gacha1Button: () => this.performGacha(1), gacha10Button: () => this.performGacha(10), closeInventoryButton: () => this.closeView('inventoryPanel'), openGachaButton: () => this.openView('gachaPanel'), closeGachaButton: () => this.closeView('gachaPanel'), openTalentButton: () => this.openView('talentPanel'), closeTalentButton: () => this.closeView('talentPanel'), openInventoryButton: () => this.openView('inventoryPanel'), restartButton: () => this.init(true), nextFloorButton: () => this.nextFloor() };
        Object.entries(buttons).forEach(([id, func]) => document.getElementById(id).addEventListener('click', func));
        document.getElementById('inventoryFilter').addEventListener('click', e => { if(e.target.dataset.filter) this.filterInventory(e.target.dataset.filter); });
        document.getElementById('weaponArea').addEventListener('click', () => this.openView('inventoryPanel', 'weapon'));
        document.getElementById('armorArea').addEventListener('click', () => this.openView('inventoryPanel', 'armor'));
        setInterval(() => { if(!this.isGameOver) this.saveGame(); }, 5000);
    }
    gameLoop(){
        this.gameLoopRunning = true; if(this.isGameOver) { this.gameLoopRunning = false; return; }
        const n = performance.now(); const dt = Math.min(n - (this.lastFrameTime || n), 100);
        this.lastFrameTime = n; this.update(dt); this.draw();
        requestAnimationFrame(() => this.gameLoop());
    }
    update(dt){
        if(this.keys['a'] || this.keys['arrowleft']) this.player.x -= 300 * (dt / 1000);
        if(this.keys['d'] || this.keys['arrowright']) this.player.x += 300 * (dt / 1000);
        this.player.x = Math.max(this.player.size, Math.min(this.canvas.width - this.player.size, this.player.x));
        this.player.skillCooldowns = this.player.skillCooldowns.map(cd => Math.max(0, cd - dt));
        this.applyTalentEffects(dt);
        for(let key of ['activeEffects', 'projectiles', 'enemies', 'particles', 'floatingTexts']){
            for(let i = this[key].length - 1; i >= 0; i--){
                const item = this[key][i]; if(item.update) item.update(dt, this.player, dmg => this.takeDamage(dmg));
                if(key === 'floatingTexts'){ item.life -= dt; item.alpha = Math.max(0, item.life / 2000); item.y -= 60 * (dt / 1000); if(item.life <= 0 || item.alpha <= 0) this[key].splice(i, 1); }
                else if(item.isDone || item.life <= 0 || (key === 'projectiles' && (item.x > 1300 || item.x < 0))) { this[key].splice(i, 1); }
            }
        }
        this.handleCollisions();
        if(this.enemies.length === 0 && !this.floorCompleted){ if(this.currentWave < this.totalWaves){ this.currentWave++; this.spawnWave(); } else { this.completeFloor(); } }
        this.updateUI();
    }
    applyTalentEffects(dt) { if(this.talents['def3']) { const regenAmount = this.player.maxHp * 0.005 * (dt / 1000); this.player.hp = Math.min(this.player.maxHp, this.player.hp + regenAmount); } if(this.talents['def8']) { const regenAmount = this.player.maxHp * 0.01 * (dt / 1000); this.player.hp = Math.min(this.player.maxHp, this.player.hp + regenAmount); } }
    handleCollisions(){ this.enemies.forEach(e => { for(let i = this.projectiles.length - 1; i >= 0; i--) { const p = this.projectiles[i]; if(Math.hypot(p.x - e.x, p.y - e.y) < e.size){ this.dealDamage(e, this.player.attackPower); if(!p.p) this.projectiles.splice(i, 1); } } }); }
    draw(){
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height); gradient.addColorStop(0, '#2c3e50'); gradient.addColorStop(1, '#34495e'); this.ctx.fillStyle = gradient; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = '#4a524a'; this.ctx.fillRect(0, this.groundY, this.canvas.width, this.canvas.height - this.groundY);
        for(let key of ['activeEffects', 'particles', 'projectiles', 'enemies']){ this[key].forEach(item => item.draw(this.ctx)); }
        this.ctx.save(); this.ctx.shadowBlur = 10; this.ctx.shadowColor = '#3498db'; this.ctx.fillStyle = '#3498db'; this.ctx.beginPath(); this.ctx.arc(this.player.x, this.player.y, this.player.size, 0, 2 * Math.PI); this.ctx.fill(); this.ctx.restore();
        this.floatingTexts.forEach(t => { this.ctx.fillStyle = `rgba(${t.c}, ${t.alpha})`; this.ctx.font = `bold ${t.s}px 'Noto Sans KR'`; this.ctx.strokeStyle = 'rgba(0,0,0,0.8)'; this.ctx.lineWidth = 3; this.ctx.strokeText(t.text, t.x, t.y); this.ctx.fillText(t.text, t.x, t.y); });
        if(this.mouse.isDown){
            const weaponItem = this.equipment.weapon || {name: '맨손'}; const w = WEAPON_DATA[weaponItem.name];
            if(w.t === 'r' || w.t === 'g'){
                const pLife = w.life; const dist = pLife / 1000 * w.v * 30; this.ctx.beginPath(); this.ctx.moveTo(this.player.x, this.player.y);
                const angle = Math.atan2(this.mouse.y - this.player.y, this.mouse.x - this.player.x); this.ctx.lineTo(this.player.x + dist * Math.cos(angle), this.player.y + dist * Math.sin(angle));
                this.ctx.strokeStyle = 'rgba(255,255,255,0.5)'; this.ctx.lineWidth = 3; this.ctx.stroke();
            } else {
                const rarityBonus = weaponItem.rarity ? Object.keys(RARITY_DATA).indexOf(weaponItem.rarity) * 0.1 : 0;
                this.ctx.save(); this.ctx.fillStyle = 'rgba(255,255,255,0.3)'; this.ctx.translate(this.player.x, this.player.y);
                if(w.e.type === 'arc'){ this.ctx.beginPath(); this.ctx.arc(0, 0, w.r * (1 + rarityBonus), -0.8, 0.8); this.ctx.lineTo(0, 0); this.ctx.fill(); }
                else if(w.e.type === 'rect'){ this.ctx.fillRect(10, -w.e.h / 2, w.e.w * (1 + rarityBonus), w.e.h); }
                this.ctx.restore();
            }
        }
    }
    attack(){
        const weaponItem = this.equipment.weapon || {name: '맨손', rarity: 'N'}; const w = WEAPON_DATA[weaponItem.name];
        let attackSpeed = w.s; if(this.talents['util1']) attackSpeed *= 1.1; if(this.talents['util6']) attackSpeed *= 1.15;
        if(Date.now() - this.lastAttackTime < 1000 / attackSpeed) return; this.lastAttackTime = Date.now();
        if(w.t === 'r' || w.t === 'g'){
            const c = w.e.count || 1; const angle = Math.atan2(this.mouse.y - this.player.y, this.mouse.x - this.player.x);
            for(let i = 0; i < c; i++){
                const spreadAngle = angle + (i - (c - 1) / 2) * (w.e.spread || 0);
                this.projectiles.push({ x: this.player.x, y: this.player.y, vx: Math.cos(spreadAngle) * w.v * 30, vy: Math.sin(spreadAngle) * w.v * 30, p: w.p, c: weaponItem ? RARITY_DATA[weaponItem.rarity].c : '#fff', life: w.life,
                    update(dt){ this.life -= dt; this.x += this.vx * (dt / 1000); this.y += this.vy * (dt / 1000); },
                    draw(ctx){ ctx.save(); ctx.shadowBlur = 8; ctx.shadowColor = this.c; ctx.fillStyle = this.c; ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, 2 * Math.PI); ctx.fill(); ctx.restore(); }
                });
            }
        } else { this.activeEffects.push(new MeleeEffect(this, weaponItem)); }
    }
    useSkill(i){
        const s = this.equipment.skills[i]; if(!s || this.player.skillCooldowns[i] > 0) return;
        const d = SKILL_DATA[s.name]; let cooldown = d.cd;
        if(this.talents['util3']) cooldown *= 0.9; if(this.talents['util6']) cooldown *= 0.85;
        this.player.skillCooldowns[i] = cooldown * 1000;
        if(this.talents['util7'] && Math.random() < 0.05) { this.player.skillCooldowns[i] = 0; this.createNotification('마력 폭주! 쿨타임 초기화!', 'success'); }
        this.activeEffects.push(new SkillEffect(this, this.player, d));
    }
    dealDamage(e, d, weaponItem = this.equipment.weapon){
        let finalDamage = d;
        if (weaponItem && weaponItem.name) { const weaponData = WEAPON_DATA[weaponItem.name]; if (weaponData) { finalDamage *= weaponData.d; } }
        if (this.talents['spec4'] && e.hp / e.maxHp <= 0.2) finalDamage *= 1.5;
        if (this.talents['spec7'] && e.isElite) finalDamage *= 1.25;
        if (this.talents['spec8']) finalDamage *= 1.2;
        if (this.talents['atk5'] && Math.random() < 0.1) { finalDamage *= 2; this.createFloatingText('결정타!', e.x, e.y - 20, '255,50,50', 24); }
        const f = Math.floor(finalDamage); e.takeDamage(f);
        this.createFloatingText(`-${f}`, e.x, e.y, '255,200,50', 20);
        if (this.talents['spec1']) { this.player.hp = Math.min(this.player.maxHp, this.player.hp + Math.ceil(f * 0.02)); }
        if (this.talents['spec2']) { const reflectDamage = Math.floor(d * 0.1); e.takeDamage(reflectDamage); }
        if(weaponItem && weaponItem.special === '흡혈 10%'){ this.player.hp = Math.min(this.player.maxHp, this.player.hp + Math.ceil(f * 0.1)); }
        if(e.hp <= 0) this.killEnemy(e, weaponItem);
    }
    killEnemy(e, w){
        if(w && w.special === '처치 시 폭발'){ this.activeEffects.push(new SkillEffect(this, this.player, {type: 'aoe', r: 80, d: 0.5, c: 'rgba(255,150,50,0.6)'})); }
        this.enemies = this.enemies.filter(en => en.id !== e.id); let expGain = e.isElite ? 80 : 30; if(this.talents['util2']) expGain *= 1.2; this.gainExp(expGain);
        let goldGain = (e.isElite ? 40 : 15) * this.currentFloor;
        if(this.talents['greed1']) goldGain *= 1.2; if(this.talents['greed7']) goldGain *= 1.3; if(this.talents['greed4'] && Math.random() < 0.05) goldGain *= 10;
        this.player.gold += Math.floor(goldGain);
        let tokenChance = 0.3; if(this.talents['greed2']) tokenChance += 0.15; if(this.talents['greed7']) tokenChance += 0.3;
        if(Math.random() < tokenChance) this.player.gachaTokens += Math.ceil(this.currentFloor / 5) + 1;
        if(this.talents['atk7']) { this.player.tempAttackBonus = (this.player.tempAttackBonus || 0) + 0.2; setTimeout(() => { this.player.tempAttackBonus -= 0.2; this.updateStats(); }, 5000); this.updateStats(); }
    }
    takeDamage(d){
        let finalDamage = d - this.player.defense; if(this.talents['def4']) finalDamage *= 0.9; if(this.talents['def8']) finalDamage *= 0.85; if(this.talents['spec8']) finalDamage *= 1.1;
        if(this.talents['def6'] && Math.random() < 0.1) { this.createFloatingText('회피!', this.player.x, this.player.y, '100,255,255', 24); return; }
        finalDamage = Math.max(1, finalDamage);
        this.player.hp -= finalDamage; this.createFloatingText(`-${Math.floor(finalDamage)}`, this.player.x, this.player.y, '255,50,50', 26);
        if(this.player.hp <= 0) {
            if(this.talents['spec3'] && !this.player.usedDeathResist) { this.player.hp = 1; this.player.usedDeathResist = true; this.createFloatingText('죽음의 저항!', this.player.x, this.player.y - 30, '255,215,0', 30); }
            else { this.gameOver(); }
        }
    }
    levelUp(){
        this.player.level++; this.player.exp = 0; this.player.expToNext = Math.floor(100 * (1.2**this.player.level));
        this.player.maxHp += 20; this.player.hp = this.player.maxHp; this.player.baseAttackPower += 2;
        let pointsGained = this.player.level <= 10 ? 1 : (this.player.level <= 25 ? 2 : 3); this.talentPoints += pointsGained;
        this.updateStats(); this.createNotification(`레벨 업! 특성 포인트 +${pointsGained}`, 'success'); this.initTalentTree();
    }
    gainExp(a){ this.player.exp += a; if(this.player.exp >= this.player.expToNext) this.levelUp(); }
    rollGacha(){
        let rarity = 'N';
        if(--this.pityCounter <= 0) {
            const highRarities = ['SSR','UR','L','U','SU','SSU','M','LM','EN','G']; rarity = highRarities[Math.floor(Math.random() * highRarities.length)]; this.pityCounter = 100;
        } else {
            const random = Math.random(); let cumulative = 0;
            for(const [key, data] of Object.entries(RARITY_DATA)) { cumulative += data.r; if(random < cumulative) { rarity = key; break; } }
        }
        const typeRandom = Math.random(); let type, namePool;
        if(typeRandom < 0.45) { type = 'weapon'; namePool = Object.keys(WEAPON_DATA).filter(name => name !== '맨손'); }
        else if(typeRandom < 0.8) { type = 'armor'; namePool = Object.keys(ARMOR_DATA); }
        else { type = 'skill'; namePool = Object.keys(SKILL_DATA); }
        const name = namePool[Math.floor(Math.random() * namePool.length)];
        const newItem = { id: `${Date.now()}${Math.random()}`, name: name, type: type, rarity: rarity, level: 0, power: Math.floor(5 * RARITY_DATA[rarity].p) };
        if(Object.keys(RARITY_DATA).indexOf(rarity) >= 4 && type === 'weapon') { newItem.special = SSR_WEAPON_SPECIALS[Math.floor(Math.random() * SSR_WEAPON_SPECIALS.length)]; }
        return newItem;
    }
    enhanceItem(id) {
        const i = this.inventory.find(it => it.id === id);
        if (!i || i.level >= 10) return;

        const level = i.level;

        // 강화 비용 계산 (2.1 지수승으로 증가)
        let cost = Math.floor(150 * Math.pow(2.3, level));
        if (this.talents['greed5']) cost = Math.floor(cost * 0.8);

        if (this.player.gold < cost) {
            this.createNotification('골드가 부족합니다!', 'error');
            return;
        }
        this.player.gold -= cost;

        // 성공 확률 (0.5^레벨)
        const successRate = Math.pow(0.5, level);
        const failRate = 1 - successRate;

        // 파괴 확률 (5레벨 이상부터 적용)
        let destroyRate = 0;
        if (level >= 5) {
            destroyRate = Math.min(0.5, 0.05 * Math.pow(level - 4, 1.3));
        }

        // 강화 결과
        if (Math.random() < successRate) {
            i.level++;
            i.power = Math.floor(i.power * 1.3);
            this.createNotification(`(+${i.level}) ${i.name} 강화 성공!`, 'success');
        } else {
            if (level >= 5 && Math.random() < destroyRate) {
                // 장비 파괴
                this.inventory = this.inventory.filter(it => it.id !== id);
                this.createNotification(`${i.name} 강화 실패! 장비가 파괴되었습니다!`, 'error');
            } else {
                // 강화 실패만
                this.createNotification('강화 실패...', 'error');
            }
        }

        this.updateStats();
        this.updateInventoryDisplay();
    }

    updateStats(){
        const w = this.equipment.weapon, a = this.equipment.armor; let baseAttack = (this.player.baseAttackPower || 5) + (w ? w.power : 0);
        let baseHp = 100 + (this.player.level - 1) * 20; let baseDefense = a ? a.power : 0;
        if(this.talents['atk1']) baseAttack *= 1.1; if(this.talents['atk6']) baseAttack *= 1.25; if(this.talents['atk8']) baseAttack *= 1.2;
        if(this.talents['def1']) baseHp *= 1.15; if(this.talents['def2']) baseDefense *= 1.2; if(this.talents['def7']) { baseHp *= 1.3; baseDefense *= 1.3; }
        if(this.talents['spec6']) { baseAttack *= 1.15; baseHp *= 1.15; baseDefense *= 1.15; }
        baseAttack *= (1 + (this.player.tempAttackBonus || 0));
        this.player.attackPower = Math.floor(baseAttack); this.player.defense = Math.floor(baseDefense); this.player.maxHp = Math.floor(baseHp);
        if(this.player.hp > this.player.maxHp) this.player.hp = this.player.maxHp; 
        this.updateUI();
    }
    startSkillEquip(slotIndex) { this.skillEquipSlot = slotIndex; this.openView('inventoryPanel', 'skill'); this.createNotification(`${slotIndex + 1}번 슬롯에 장착할 스킬을 선택하세요.`, 'info'); }
    equipSkill(item) {
        if (this.skillEquipSlot === -1 || item.type !== 'skill') return;
        const isAlreadyEquipped = this.equipment.skills.some(s => s && s.id === item.id);
        if (isAlreadyEquipped) { this.createNotification('이미 다른 슬롯에 장착된 스킬입니다.', 'error'); return; }
        this.equipment.skills[this.skillEquipSlot] = item;
        this.createNotification(`${item.name} 스킬을 ${this.skillEquipSlot + 1}번에 장착했습니다.`, 'success');
        this.skillEquipSlot = -1; this.closeView('inventoryPanel'); this.updateUI();
    }
    updateUI(){
        const statMappings = { 'playerLevel': this.player.level, 'playerExp': Math.ceil(this.player.exp), 'expToNext': this.player.expToNext, 'playerHP': Math.ceil(this.player.hp), 'playerMaxHP': this.player.maxHp, 'playerAttack': this.player.attackPower, 'playerDefense': this.player.defense, 'playerGold': this.player.gold.toLocaleString(), 'gachaTokens': this.player.gachaTokens, 'talentPoints': this.talentPoints, 'availableTalentPoints': this.talentPoints, 'currentFloor': this.currentFloor, 'currentWave': this.currentWave, 'pityCounter': this.pityCounter };
        Object.entries(statMappings).forEach(([id, val]) => { const el = document.getElementById(id); if(el) el.textContent = val; });
        document.getElementById('hpBar').style.width = `${Math.max(0, this.player.hp / this.player.maxHp * 100)}%`; document.getElementById('expBar').style.width = `${this.player.exp / this.player.expToNext * 100}%`;
        const baseSpeed = this.equipment.weapon ? WEAPON_DATA[this.equipment.weapon.name].s : 1.2; let finalSpeed = baseSpeed;
        if(this.talents['util1']) finalSpeed *= 1.1; if(this.talents['util6']) finalSpeed *= 1.15;
        document.getElementById('playerAttackSpeed').textContent = finalSpeed.toFixed(1);
        ['weapon', 'armor'].forEach(type => {
            const item = this.equipment[type]; const slot = document.getElementById(`${type}Slot`);
            if(item) {
                const rarityData = RARITY_DATA[item.rarity];
                slot.innerHTML = `<div style="font-size: 11px; margin-top: 2px;"><span style="color:${rarityData.c}">(${item.rarity})</span> ${item.name}<br>+${item.level}</div>`;
                slot.style.borderColor = rarityData.c; slot.classList.add('filled');
            } else {
                const defaultText = type === 'weapon' ? '맨손' : '없음';
                slot.innerHTML = `<div style="font-size: 11px; margin-top: 2px;">${defaultText}</div>`;
                slot.style.borderColor = '#666'; slot.classList.remove('filled');
            }
        });
        this.equipment.skills.forEach((skill, index) => {
            const slot = document.getElementById(`skillSlot${index}`);
            if(skill) {
                slot.innerHTML = `<div style="font-size: 10px; margin-top: 2px;"><span style="color:${RARITY_DATA[skill.rarity].c}">(${skill.rarity})</span><br>${skill.name}</div><div class="cooldown-overlay"></div>`;
                slot.style.borderColor = RARITY_DATA[skill.rarity].c; slot.classList.add('filled');
                const isReady = this.player.skillCooldowns[index] <= 0; slot.classList.toggle('skill-ready', isReady);
                const cooldownOverlay = slot.querySelector('.cooldown-overlay'); if(cooldownOverlay) { const cooldownPercent = this.player.skillCooldowns[index] / (SKILL_DATA[skill.name].cd * 1000) * 100; cooldownOverlay.style.height = `${Math.max(0, cooldownPercent)}%`; }
            } else {
                slot.innerHTML = `<div class="cooldown-overlay"></div><div style="font-size: 9px;">빈 슬롯</div>`;
                slot.style.borderColor = '#666'; slot.classList.remove('filled', 'skill-ready');
                const cooldownOverlay = slot.querySelector('.cooldown-overlay'); if(cooldownOverlay) cooldownOverlay.style.height = '0%';
            }
        });
    }
    performGacha(count) {
        const cost = count === 1 ? 10 : 90; if(this.player.gachaTokens < cost) { this.createNotification('토큰이 부족합니다!', 'error'); return; }
        this.player.gachaTokens -= cost; const results = Array.from({ length: count }, () => this.rollGacha());
        this.inventory.push(...results); this.showGachaResult(results); this.updateUI();
    }
    showGachaResult(results) {
        const container = document.getElementById('gachaResultContent'); container.innerHTML = '';
        results.forEach((item, index) => {
            const card = document.createElement('div'); card.className = 'gacha-card';
            const inner = document.createElement('div'); inner.className = 'gacha-card-inner';
            const front = document.createElement('div'); front.className = 'gacha-card-front'; front.innerHTML = '<div>?</div>';
            const back = document.createElement('div'); back.className = 'gacha-card-back';
            const rarityData = RARITY_DATA[item.rarity]; back.style.background = `radial-gradient(ellipse at center, ${rarityData.c} 0%, #000 100%)`;
            back.style.color = item.rarity === 'G' ? '#000' : '#fff';
            back.innerHTML = `<strong style="color:${rarityData.c}; text-shadow: 0 0 15px ${rarityData.c}; font-size: 14px;">${item.rarity}</strong><div style="margin: 8px 0; font-size: 12px; font-weight: bold;">${item.name}</div>${item.special ? `<div style="color: gold; font-size: 10px; margin-top: 5px;">${item.special}</div>` : ''}`;
            inner.appendChild(front); inner.appendChild(back); card.appendChild(inner); container.appendChild(card);
            setTimeout(() => {
                card.classList.add('is-flipped');
                const rarityIndex = Object.keys(RARITY_DATA).indexOf(item.rarity);
                if(rarityIndex >= 4) {
                    for(let i = 0; i < 30 + rarityIndex * 10; i++) { this.particles.push(new Particle(this.canvas.width/2, this.canvas.height/2, rarityData.c, Math.random() * 6 + 2, 200 + rarityIndex * 50, 1000 + rarityIndex * 200)); }
                    if(rarityIndex >= 6) this.createNotification(`${item.rarity} 등급 ${item.name} 획득!`, 'success');
                }
            }, 150 + index * 200);
        });
    }
    initTalentTree() {
        const container = document.getElementById('talent-container'); container.innerHTML = '';
        for (const categoryId in TALENT_DATA) {
            const category = TALENT_DATA[categoryId]; const treeDiv = document.createElement('div'); treeDiv.className = 'talent-tree';
            const nameDiv = document.createElement('div'); nameDiv.className = 'talent-tree-name'; nameDiv.textContent = category.name; treeDiv.appendChild(nameDiv);
            const nodesContainer = document.createElement('div'); nodesContainer.className = 'talent-nodes-container';
            category.talents.forEach((talent, index) => {
                const wrapper = document.createElement('div'); wrapper.className = 'talent-node-wrapper';
                const node = document.createElement('div'); node.className = 'talent-node';
                node.innerHTML = `<div class="talent-node-name">${talent.name}</div><div class="talent-node-desc">${talent.desc}</div><div class="talent-node-cost">비용: ${talent.cost}</div>`;
                const isUnlocked = this.talents[talent.id]; const canUnlock = this.canUnlockTalent(talent);
                if (isUnlocked) node.classList.add('unlocked');
                else if (canUnlock) { node.classList.add('available'); node.addEventListener('click', () => this.unlockTalent(talent)); }
                wrapper.appendChild(node);
                if(index < category.talents.length - 1) { const connector = document.createElement('div'); connector.className = 'talent-connector'; wrapper.appendChild(connector); }
                nodesContainer.appendChild(wrapper);
            });
            treeDiv.appendChild(nodesContainer); container.appendChild(treeDiv);
        }
    }
    canUnlockTalent(talent) {
        if (this.talents[talent.id]) return false;
        if (this.talentPoints < talent.cost) return false;
        if (talent.prereq && !this.talents[talent.prereq]) return false;
        return true;
    }
    unlockTalent(talent) {
        if (!this.canUnlockTalent(talent)) return;
        this.talentPoints -= talent.cost; this.talents[talent.id] = true;
        this.createNotification(`${talent.name} 특성을 획득했습니다!`, 'success');
        this.updateStats(); this.initTalentTree();
    }
    createNotification(message, type = 'info') { const area = document.getElementById('notification-area'); const notif = document.createElement('div'); notif.className = 'notification'; notif.textContent = message; const colors = { success: '#2ecc71', error: '#e74c3c', warning: '#f1c40f', info: '#3498db' }; notif.style.borderColor = colors[type] || colors.info; notif.style.backgroundColor = (colors[type] || colors.info).replace(')', ', 0.9)').replace('rgb', 'rgba'); area.appendChild(notif); setTimeout(() => { if(notif.parentNode) notif.parentNode.removeChild(notif); }, 4000); }
    equipItem(item) {
        if (this.skillEquipSlot !== -1 && item.type === 'skill') { this.equipSkill(item); return; }
        if(item.type === 'weapon') this.equipment.weapon = item;
        else if(item.type === 'armor') this.equipment.armor = item;
        this.updateStats(); this.updateInventoryDisplay(); this.createNotification(`${item.name} 장착 완료!`, 'success');
    }
    filterInventory(filter) { this.inventoryFilter = filter; this.updateInventoryDisplay(); }
    createFloatingText(text, x, y, color = '255,255,255', size = 20) { this.floatingTexts.push({ text, x, y, c: color, s: size, alpha: 1, life: 2000 }); }
    openModal(id) { document.getElementById('modal-backdrop').style.display = 'flex'; document.getElementById(id).style.display = 'block'; }
    closeModal(id) { document.getElementById('modal-backdrop').style.display = 'none'; document.getElementById(id).style.display = 'none'; }
    gameOver() { this.isGameOver = true; document.getElementById('finalFloor').textContent = this.currentFloor; this.openModal('gameOverScreen'); localStorage.removeItem('hackSlashGame_v23'); }
    spawnWave() {
        const enemyCount = Math.min(3 + Math.floor(this.currentFloor * 1.5), 15); const eliteChance = Math.min(0.1 + (this.currentFloor * 0.05), 0.4);
        for(let i = 0; i < enemyCount; i++) { this.enemies.push(new Enemy(this, Math.random() < eliteChance)); }
    }
    completeFloor() {
        this.floorCompleted = true;
        let goldReward = Math.floor(150 * this.currentFloor * (1 + this.currentFloor * 0.1)); let tokenReward = Math.floor(8 * this.currentFloor + (this.currentFloor > 10 ? this.currentFloor * 2 : 0));
        if (this.talents['greed8']) { goldReward = Math.floor(goldReward * 1.2); tokenReward = Math.floor(tokenReward * 1.2); }
        this.player.gold += goldReward; this.player.gachaTokens += tokenReward; let bonusHtml = '';
        if(this.currentFloor % 10 === 0) {
            const bonusTokens = this.currentFloor * 5; this.player.gachaTokens += bonusTokens;
            bonusHtml = `<div style="color: #f1c40f; font-weight: bold;">10층 돌파 보너스! 토큰 +${bonusTokens}</div>`;
            this.createNotification(`${this.currentFloor}층 달성 보너스! +${bonusTokens} 토큰!`, 'success');
        }
        document.getElementById('floorReward').innerHTML = `<h2>${this.currentFloor}층 클리어!</h2><p>골드 +${goldReward.toLocaleString()}</p><p>토큰 +${tokenReward}</p>${bonusHtml}`;
        this.openModal('floorInfo');
    }
    nextFloor() { this.currentFloor++; this.currentWave = 1; this.floorCompleted = false; this.closeModal('floorInfo'); this.spawnWave(); }
    updateInventoryDisplay() {
        const list = document.getElementById('inventoryList'); list.innerHTML = '';
        const filtered = this.inventory.filter(i => this.inventoryFilter === 'all' || i.type === this.inventoryFilter);
        filtered.sort((a, b) => Object.keys(RARITY_DATA).indexOf(b.rarity) - Object.keys(RARITY_DATA).indexOf(a.rarity));
        filtered.forEach(item => {
            const div = document.createElement('div'); div.className = `item ${item.rarity}`;
            const rarityColor = RARITY_DATA[item.rarity].c; div.style.borderLeftColor = rarityColor;
            div.onclick = () => this.equipItem(item);
            if(Object.values(this.equipment).flat().some(e => e?.id === item.id)) div.classList.add('equipped');
            let cost = Math.floor(150 * Math.pow(2.3, item.level)); if (this.talents['greed5']) cost = Math.floor(cost * 0.8);
            const itemDiv = document.createElement('div');
            itemDiv.innerHTML = `<div style="display:flex;align-items:center;gap:10px;"><div><strong style="color:${rarityColor}">(${item.rarity}) ${item.name} (+${item.level})</strong><br><small>능력치: ${item.power}${item.special?' | '+item.special:''}</small></div></div>`;
            const enhanceBtn = document.createElement('button'); enhanceBtn.className = 'button'; enhanceBtn.textContent = `강화 (${cost.toLocaleString()}G)`;
            enhanceBtn.disabled = item.level >= 10 || this.player.gold < cost;
            enhanceBtn.onclick = (e) => { e.stopPropagation(); this.enhanceItem(item.id); };
            div.appendChild(itemDiv); div.appendChild(enhanceBtn); list.appendChild(div);
        });
    }
    openView(panelId, filter) {
        document.getElementById(panelId).style.display = 'block';
        if(panelId === 'inventoryPanel') this.filterInventory(filter || 'all');
        else if(panelId === 'talentPanel') this.initTalentTree();
    }
    closeView(panelId) { document.getElementById(panelId).style.display = 'none'; if(panelId === 'inventoryPanel') { this.skillEquipSlot = -1; } }
    saveGame() {
        const data = { p: this.player, e: this.equipment, i: this.inventory, f: this.currentFloor, c: this.pityCounter, t: this.talents, tp: this.talentPoints };
        localStorage.setItem('hackSlashGame_v23', JSON.stringify(data));
    }
    loadGame() {
        const data = localStorage.getItem('hackSlashGame_v23');
        if(data) {
            try {
                const s = JSON.parse(data);
                if (s.p) Object.assign(this.player, s.p);
                if (s.e) this.equipment = s.e;
                if (s.i) this.inventory = s.i;
                if (s.t) this.talents = s.t;
                this.currentFloor = s.f || 1; this.pityCounter = s.c || 100; this.talentPoints = s.tp || 0;
            } catch(e) { console.error("Save Load Failed, resetting:", e); localStorage.removeItem('hackSlashGame_v23'); this.resetPlayerState(); }
        }
    }
}
window.onload = () => { window.game = new Game(); };
</script>
</body>
</html>
