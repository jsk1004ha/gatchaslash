<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>핵앤슬래시 갸챠 게임 v1.1</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --panel-bg: rgba(10, 10, 25, 0.95);
            --border-gradient: linear-gradient(to right, #b8860b, #ffd700, #b8860b);
            --font-color: #ecf0f1;
            --primary-color: #3498db;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --warn-color: #f1c40f;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Noto Sans KR', 'Arial', sans-serif; background: #1a1a1a; color: var(--font-color); overflow: hidden; display: flex; align-items: center; justify-content: center; height: 100vh; }
        #gameContainer { width: 1280px; height: 720px; position: relative; background-color: #000; box-shadow: 0 0 40px rgba(74, 144, 226, 0.4); border-radius: 10px; overflow: hidden; }
        #gameCanvas { background: linear-gradient(to bottom, #2c3e50, #34495e); display: block; width: 100%; height: 100%; cursor: crosshair; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; }
        .ui-panel { position: absolute; background: var(--panel-bg); border: 3px solid; border-image-slice: 1; border-image-source: var(--border-gradient); padding: 15px; pointer-events: auto; backdrop-filter: blur(10px); font-size: 14px; border-radius: 8px; }
        #statsPanel { top: 20px; left: 20px; width: 300px; }
        #equipmentPanel { top: 20px; right: 20px; width: 300px; }
        #inventoryPanel, #gachaPanel, #talentPanel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 900px; max-height: 85vh; display: none; z-index: 21; overflow-y: auto; }
        #bottomUIPanel { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); width: 600px; text-align: center; pointer-events: auto; }
        #modal-backdrop { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; z-index: 200; align-items: center; justify-content: center;}
        .modal { text-align: center; background: var(--panel-bg); padding: 40px; border-radius: 15px; border: 3px solid; border-image-slice: 1; border-image-source: var(--border-gradient); }
        .button { background: var(--primary-color); border: 2px solid #fff; color: white; padding: 10px 18px; margin: 6px; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.3s; font-family: 'Noto Sans KR', sans-serif; }
        .button:hover { filter: brightness(1.3); transform: translateY(-2px); box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4); }
        .button:disabled { background: #555; cursor: not-allowed; transform: none; }
        .item { margin: 8px 0; padding: 12px; border-left: 5px solid; cursor: pointer; transition: all 0.3s; background: rgba(255, 255, 255, 0.08); display: flex; justify-content: space-between; align-items: center; border-radius: 6px; }
        .item:hover { background: rgba(255, 255, 255, 0.12); transform: translateX(5px); }
        .item.equipped { background: linear-gradient(90deg, rgba(46, 204, 113, 0.3), transparent) !important; border: 2px solid var(--success-color); }
        .progress-bar { width: 100%; height: 14px; background: #333; border-radius: 8px; overflow: hidden; margin: 10px 0; border: 2px solid #555; }
        .progress-fill { height: 100%; transition: width 0.6s ease; }
        #expBar { background: linear-gradient(90deg, #27ae60, #f1c40f, #e67e22); }
        #hpBar { background: linear-gradient(90deg, #c0392b, #e74c3c, #ff6b6b); }
        .equipment-area { cursor: pointer; padding: 5px; margin-bottom: 10px; border-radius: 5px; transition: background-color 0.3s; }
        .equipment-area:hover { background-color: rgba(255,255,255,0.1); }
        .equipment-slot, .skill-slot { display: inline-flex; align-items: center; justify-content: center; width: 70px; height: 70px; border: 3px dashed #666; margin: 6px; background: rgba(0, 0, 0, 0.6); text-align: center; font-size: 11px; cursor: pointer; transition: all 0.4s; position: relative; padding: 8px; overflow: hidden; word-wrap: break-word; border-radius: 10px; }
        .equipment-slot.filled, .skill-slot.filled { border-style: solid; background: rgba(255, 255, 255, 0.1); }
        .equipment-slot:hover, .skill-slot:hover { transform: scale(1.05); border-color: var(--primary-color); }
        .cooldown-overlay { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0,0,0,0.8); transition: height 0.1s linear; pointer-events: none; border-radius: 0 0 7px 7px; }
        .skill-ready { animation: skillPulse 1.5s infinite; }
        @keyframes skillPulse { 0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.8); } 70% { box-shadow: 0 0 0 15px rgba(46, 204, 113, 0); } 100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); } }
        h3 { color: var(--warn-color); margin-bottom: 15px; font-size: 18px; border-bottom: 2px solid; border-image: var(--border-gradient) 1; padding-bottom: 8px; text-transform: uppercase; font-weight: 700; }
        .stat-row { margin: 8px 0; display: flex; justify-content: space-between; font-weight: 500; }
        .stat-value { color: var(--warn-color); font-weight: 700; }
        .damage-text { position: absolute; font-weight: bold; pointer-events: none; animation: floatUp 2s ease-out forwards; text-shadow: 2px 2px 4px #000; font-size: 18px; }
        @keyframes floatUp { to { transform: translateY(-100px); opacity: 0; } }
        #notification-area { position: absolute; top: 30px; left: 50%; transform: translateX(-50%); z-index: 1000; display: flex; flex-direction: column; align-items: center; gap: 12px; }
        .notification { padding: 12px 25px; background: rgba(0,0,0,0.9); border-radius: 8px; animation: notificationSlide 4s forwards; border: 2px solid var(--primary-color); font-weight: 600; }
        @keyframes notificationSlide { 0% { opacity: 0; transform: translateY(-30px); } 10%, 80% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-30px); } }
        #gachaResultContent { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; }
        .gacha-card { width: 140px; height: 200px; perspective: 1000px; }
        .gacha-card-inner { position: relative; width: 100%; height: 100%; transition: transform 0.8s; transform-style: preserve-3d; }
        .gacha-card.is-flipped .gacha-card-inner { transform: rotateY(180deg); }
        .gacha-card-front, .gacha-card-back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 15px; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 12px; border: 3px solid #ffd700; }
        .gacha-card-front { background: linear-gradient(45deg, #6a82fb, #fc5c7d); }
        .gacha-card-back { transform: rotateY(180deg); }
        #talentPanel { width: 1100px; }
        #talent-container { display: flex; flex-direction: column; gap: 15px; }
        .talent-tree { display: flex; align-items: center; padding: 10px; border: 2px solid #555; border-radius: 8px; }
        .talent-tree-name { font-size: 16px; font-weight: bold; color: var(--primary-color); width: 120px; text-align: center; flex-shrink: 0; }
        .talent-nodes-container { display: flex; align-items: center; overflow-x: auto; }
        .talent-node-wrapper { display: flex; align-items: center; }
        .talent-node { width: 100px; height: 100px; border: 3px solid #666; border-radius: 15px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.4s; background: rgba(0,0,0,0.8); font-size: 11px; text-align: center; padding: 5px; position: relative; flex-shrink: 0;}
        .talent-connector { width: 30px; height: 5px; background-color: #666; }
        .talent-node.unlocked { border-color: var(--success-color); background: rgba(46, 204, 113, 0.3); transform: scale(1.05); }
        .talent-node.unlocked + .talent-connector { background-color: var(--success-color); }
        .talent-node.available { border-color: var(--warn-color); animation: talentGlow 2s infinite; }
        .talent-node-name { font-weight: bold; font-size: 12px; }
        .talent-node-desc { font-size: 9px; margin: 3px 0; }
        .talent-node-cost { font-size: 9px; color: #f1c40f; }
        @keyframes talentGlow { 0%, 100% { box-shadow: 0 0 8px var(--warn-color); } 50% { box-shadow: 0 0 25px var(--warn-color); } }
        .floor-display { font-size: 20px; font-weight: 700; color: var(--warn-color); text-shadow: 0 0 10px var(--warn-color); }
        .status-effect { position: absolute; top: -5px; right: -5px; width: 15px; height: 15px; border-radius: 50%; font-size: 8px; display: flex; align-items: center; justify-content: center; }
        .poison { background: #8e44ad; }
        .burn { background: #e74c3c; }
        .freeze { background: #3498db; }
        .stun { background: #f39c12; }
        #pauseIndicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 48px; color: #f1c40f; text-shadow: 0 0 20px #f1c40f; z-index: 15; display: none; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="pauseIndicator"></div>
        <div id="ui">
            <div id="statsPanel" class="ui-panel">
                <h3>플레이어 정보</h3>
                <div class="stat-row"><span>레벨:</span><span class="stat-value" id="playerLevel">1</span></div>
                <div class="stat-row"><span>경험치:</span><span><span class="stat-value" id="playerExp">0</span> / <span id="expToNext">100</span></span></div>
                <div class="progress-bar"><div id="expBar" class="progress-fill"></div></div>
                <div class="stat-row"><span>체력:</span><span><span class="stat-value" id="playerHP">100</span> / <span id="playerMaxHP">100</span></span></div>
                <div class="progress-bar"><div id="hpBar" class="progress-fill"></div></div>
                <div class="stat-row"><span>공격력:</span><span class="stat-value" id="playerAttack">5</span></div>
                <div class="stat-row"><span>공격속도:</span><span class="stat-value" id="playerAttackSpeed">1.0</span></div>
                <div class="stat-row"><span>방어력:</span><span class="stat-value" id="playerDefense">0</span></div>
                <div class="stat-row"><span>치명타 확률:</span><span class="stat-value" id="playerCritRate">5%</span></div>
                <div class="stat-row"><span>골드:</span><span class="stat-value" id="playerGold">1000</span></div>
                <div class="stat-row"><span>토큰:</span><span class="stat-value" id="gachaTokens">100</span></div>
                <div class="stat-row"><span>펫 큐브:</span><span class="stat-value" id="playerPetCubes">0</span></div>
                <div class="stat-row"><span>특성 포인트:</span><span class="stat-value" id="talentPoints">0</span></div>
                <div class="stat-row"><span>전직 포인트:</span><span class="stat-value" id="advancementPoints">0</span></div>
                <div class="stat-row"><span>직업:</span><span class="stat-value" id="playerJob">없음</span></div>
                <div class="stat-row floor-display"><span>층수:</span><span><span id="currentFloor">1</span>-<span id="currentWave">1</span></span></div>
            </div>
            
            <div id="equipmentPanel" class="ui-panel">
                <h3>장비</h3>
                <div id="weaponArea" class="equipment-area">
                    <span>무기: </span>
                    <div class="equipment-slot" id="weaponSlot">맨손</div>
                </div>
                <div id="armorArea" class="equipment-area">
                    <span>방어구: </span>
                    <div class="equipment-slot" id="armorSlot">없음</div>
                </div>
                <div id="petArea" class="equipment-area">
                    <span>펫: </span>
                    <div class="equipment-slot" id="petSlot">없음</div>
                </div>
                <h3 style="margin-top:20px;">스킬 (1,2,3,4)</h3>
                <div id="skillSlots">
                    <div class="skill-slot" id="skillSlot0" onclick="game.startSkillEquip(0)">
                        <div class="cooldown-overlay"></div>
                        <div style="font-size: 9px;">빈 슬롯</div>
                    </div>
                    <div class="skill-slot" id="skillSlot1" onclick="game.startSkillEquip(1)">
                        <div class="cooldown-overlay"></div>
                        <div style="font-size: 9px;">빈 슬롯</div>
                    </div>
                    <div class="skill-slot" id="skillSlot2" onclick="game.startSkillEquip(2)">
                        <div class="cooldown-overlay"></div>
                        <div style="font-size: 9px;">빈 슬롯</div>
                    </div>
                    <div class="skill-slot" id="skillSlot3" onclick="game.startSkillEquip(3)">
                        <div class="cooldown-overlay"></div>
                        <div style="font-size: 9px;">빈 슬롯</div>
                    </div>
                </div>
                <h3 style="margin-top:20px;">직업 스킬 (Q,W)</h3>
                <div id="jobSkillSlots">
                    <div class="skill-slot" id="jobSkillSlot0">
                        <div class="cooldown-overlay"></div>
                        <div style="font-size: 9px;">-</div>
                    </div>
                    <div class="skill-slot" id="jobSkillSlot1">
                        <div class="cooldown-overlay"></div>
                        <div style="font-size: 9px;">-</div>
                    </div>
                </div>
            </div>
            
            <div id="inventoryPanel" class="ui-panel">
                <h3>인벤토리 <button id="closeInventoryButton" class="button" style="float:right; padding: 4px 12px;">닫기</button></h3>
                <div id="inventoryFilter">
                    <button class="button" data-filter="all">전체</button>
                    <button class="button" data-filter="weapon">무기</button>
                    <button class="button" data-filter="armor">방어구</button>
                    <button class="button" data-filter="skill">스킬</button>
                </div>
                <div id="inventoryList" style="margin-top: 15px; height: 450px; overflow-y: auto;"></div>
            </div>
            
            <div id="gachaPanel" class="ui-panel">
                <h3>갸챠 <button id="closeGachaButton" class="button" style="float:right; padding: 4px 12px;">닫기</button></h3>
                <div style="margin-bottom: 15px;">천장 카운터 (SSR+): <span class="stat-value" id="pityCounter">100</span></div>
                <div id="gachaResultContent"></div>
                <div style="margin-top: 20px;">
                    <button class="button" id="gacha1Button">1회 뽑기 (10토큰)</button>
                    <button class="button" id="gacha10Button">10회 뽑기 (90토큰)</button>
                    <button class="button" id="petGacha1Button" style="background-color: #8e44ad;">펫 1회 뽑기 (5큐브)</button>
                </div>
            </div>
            
            <div id="talentPanel" class="ui-panel">
                <h3>특성 트리 <button id="closeTalentButton" class="button" style="float:right; padding: 4px 12px;">닫기</button></h3>
                <p style="margin-bottom: 15px;">사용 가능한 특성 포인트: <span class="stat-value" id="availableTalentPoints">0</span></p>
                <div id="job-advancement-container" style="display:none; margin-bottom: 20px; padding: 15px; border: 2px solid var(--warn-color); border-radius: 8px; text-align: center;">
                    <h4>전직 가능! (사용 가능한 전직 포인트: <span id="availableAdvancementPoints">0</span>)</h4>
                    <p>전직 포인트를 사용하여 직업을 선택하세요. 직업은 되돌릴 수 없습니다.</p>
                    <div id="job-selection-buttons" style="margin-top:10px;"></div>
                </div>
                <div id="talent-container"></div>
            </div>
            
            <div id="petPanel" class="ui-panel">
                <h3>펫 관리 <button id="closePetButton" class="button" style="float:right; padding: 4px 12px;">닫기</button></h3>
                <div id="petList" style="margin-top: 15px; height: 450px; overflow-y: auto;"></div>
            </div>

            <div id="synthesisPanel" class="ui-panel" style="display:none; width: 700px; text-align: center;">
                <h3>장비 합성 <button id="closeSynthesisButton" class="button" style="float:right; padding: 4px 12px;">닫기</button></h3>
                <p>동일한 등급, 동일한 종류의 장비 3개를 합성하여 상위 등급의 장비를 얻을 수 있습니다.</p>
                <div id="synthesisSlotsContainer" style="display: flex; justify-content: space-around; align-items: center; margin: 20px 0;">
                    <div class="equipment-slot synthesis-slot" data-slot="0"></div>
                    <div class="equipment-slot synthesis-slot" data-slot="1"></div>
                    <div class="equipment-slot synthesis-slot" data-slot="2"></div>
                    <div style="font-size: 30px;">→</div>
                    <div class="equipment-slot" id="synthesisResultSlot">?</div>
                </div>
                <div id="synthesisInfo">
                    <p>비용: <span id="synthesisCost">0</span> 골드</p>
                    <p>성공 확률: <span id="synthesisChance">0</span>%</p>
                </div>
                <button id="synthesizeButton" class="button" disabled>합성</button>
            </div>
            
            <div id="bottomUIPanel">
                <button class="button" id="openGachaButton">갸챠</button>
                <button class="button" id="openTalentButton">특성</button>
                <button class="button" id="openInventoryButton">인벤토리</button>
                <button class="button" id="openPetButton">펫 관리</button>
                <button class="button" id="openSynthesisButton">장비 합성</button>
                <button class="button" id="resetGameButton" style="background-color: var(--danger-color);">게임 초기화</button>
            </div>
        </div>
        
        <div id="modal-backdrop">
            <div id="floorInfo" class="modal" style="display:none;">
                <h2>층 클리어!</h2>
                <p id="floorReward"></p>
                <button class="button" id="nextFloorButton">다음 층</button>
            </div>
            <div id="gameOverScreen" class="modal" style="display:none;">
                <h2>게임 오버</h2>
                <p>최종 층수: <span class="stat-value" id="finalFloor">1</span></p>
                <button class="button" id="restartButton">다시 시작</button>
            </div>
            <div id="skillUpgradeModal" class="modal" style="display:none; width: 600px;">
                <h2 id="skillUpgradeTitle">스킬 업그레이드</h2>
                <p id="skillUpgradeDesc" style="margin-bottom: 20px;"></p>
                <div id="skillUpgradeOptions" style="margin-top: 20px; display: flex; flex-direction: column; align-items: center; gap: 15px;">
                </div>
            </div>
        </div>
        <div id="notification-area"></div>
    </div>

<script>
// ==================================
// 데이터 정의 (v25.0)
// ==================================
const RARITY_DATA = {
    N:   {r: 0.4599999, c:'#95a5a6', p:1.0}, E:   {r: 0.2500000, c:'#2ecc71', p:1.8}, 
    R:   {r: 0.1500000, c:'#3498db', p:3.2}, S:   {r: 0.0800000, c:'#9b59b6', p:5.8},
    SSR: {r: 0.0070000, c:'#f1c40f', p:15.0}, UR:  {r: 0.0020000, c:'#e67e22', p:30.0},
    L:   {r: 0.0008000, c:'#e74c3c', p:60.0}, U:   {r: 0.0001000, c:'#ff1493', p:120.0},
    SU:  {r: 0.0000500, c:'#00ffff', p:240.0}, SSU: {r: 0.0000300, c:'#adff2f', p:480.0},
    M:   {r: 0.0000100, c:'#ffdead', p:960.0}, LM:  {r: 0.0000080, c:'#f0e68c', p:1920.0},
    EN:  {r: 0.0000020, c:'#dda0dd', p:3840.0}, G:   {r: 0.0000001, c:'#ffffff', p:7680.0}
};

function drawWeaponShapes(ctx, shape, x, y, angle, scale, color, rarity) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.scale(scale, scale);
    ctx.fillStyle = color;
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;

    const rarityIndex = Object.keys(RARITY_DATA).indexOf(rarity);
    if (rarityIndex >= 4) { // SSR+
        ctx.shadowBlur = 15 + (rarityIndex - 4) * 3;
        ctx.shadowColor = RARITY_DATA[rarity].c;
    }

    ctx.beginPath();
    switch (shape) {
        case 'sword':
            ctx.moveTo(0, -5); ctx.lineTo(80, -5); ctx.lineTo(85, 0); ctx.lineTo(80, 5);
            ctx.lineTo(0, 5); ctx.lineTo(0, 15); ctx.lineTo(-10, 15);
            ctx.lineTo(-10, -15); ctx.lineTo(0, -15); ctx.closePath();
            break;
        case 'axe':
            ctx.moveTo(0, 0); ctx.lineTo(30,0);
            ctx.lineTo(30,-20); ctx.lineTo(70,-20); ctx.arcTo(80,0,70,20, 20); ctx.lineTo(30,20);
            ctx.closePath();
            break;
        case 'hammer':
            ctx.rect(30, -25, 60, 50);
            ctx.moveTo(0,0); ctx.lineTo(30,0);
            break;
        case 'spear':
            ctx.moveTo(0,0); ctx.lineTo(150, 0); ctx.lineTo(160, -8);
            ctx.lineTo(180, 0); ctx.lineTo(160, 8); ctx.lineTo(150,0);
            break;
        case 'dagger':
             ctx.moveTo(0, -4); ctx.lineTo(60, -4); ctx.lineTo(70, 0);
             ctx.lineTo(60, 4); ctx.lineTo(0, 4); ctx.closePath();
            break;
        case 'arrow':
            ctx.moveTo(0, 0); ctx.lineTo(-20, 0);
            ctx.moveTo(0, 0); ctx.lineTo(-10, -5);
            ctx.moveTo(0, 0); ctx.lineTo(-10, 5);
            ctx.lineWidth = 3; ctx.strokeStyle = color; ctx.stroke();
            if (rarityIndex >= 2) { ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(-25, -7); ctx.moveTo(-20, 0); ctx.lineTo(-25, 7); ctx.stroke(); }
            break;
        case 'magic_bolt':
        case 'fireball':
            ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
            if (rarityIndex >= 3) { ctx.save(); ctx.globalAlpha = Math.random() * 0.5 + 0.3; ctx.beginPath(); ctx.arc(0, 0, 12 + rarityIndex, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
            break;
        default:
             ctx.rect(10, -8, 50, 16);
    }
    if(shape !== 'arrow') {
        ctx.fill();
        ctx.stroke();
    }
    ctx.restore();
}

function drawPetShapes(ctx, shape, x, y, scale, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.fillStyle = color;
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;

    switch (shape) {
        case 'dragon':
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2); // head
            ctx.moveTo(-10, -10); ctx.lineTo(-20, -20); ctx.lineTo(-15, -10); // horn 1
            ctx.moveTo(10, -10); ctx.lineTo(20, -20); ctx.lineTo(15, -10); // horn 2
            ctx.moveTo(-12, 0); ctx.quadraticCurveTo(-25, 10, -12, 20); // wing 1
            ctx.moveTo(12, 0); ctx.quadraticCurveTo(25, 10, 12, 20); // wing 2
            ctx.fill();
            ctx.stroke();
            break;
        case 'fairy':
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2); // body
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-8, 0); ctx.ellipse(-15, 0, 4, 8, 0, 0, Math.PI * 2); // left wing
            ctx.moveTo(8, 0); ctx.ellipse(15, 0, 4, 8, 0, 0, Math.PI * 2); // right wing
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();
            break;
        case 'golem':
            ctx.fillRect(-15, -20, 30, 30); // head
            ctx.strokeRect(-15, -20, 30, 30);
            ctx.fillRect(-10, 10, 20, 10); // body
            ctx.strokeRect(-10, 10, 20, 10);
            break;
        case 'wisp':
            ctx.shadowBlur = 20;
            ctx.shadowColor = color;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            break;
        case 'ghost':
            ctx.beginPath();
            ctx.moveTo(-15, 20);
            ctx.quadraticCurveTo(-15, 0, 0, 0);
            ctx.quadraticCurveTo(15, 0, 15, 20);
            ctx.lineTo(10, 15);
            ctx.lineTo(5, 20);
            ctx.lineTo(0, 15);
            ctx.lineTo(-5, 20);
            ctx.lineTo(-10, 15);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // eyes
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(-5, 5, 2, 0, Math.PI * 2);
            ctx.arc(5, 5, 2, 0, Math.PI * 2);
            ctx.fill();
            break;
    }
    ctx.restore();
}

const SSR_WEAPON_SPECIALS = [
    '흡혈 10%', '처치 시 폭발', '연쇄 번개', '방어력 무시 15%', '치명타 시 출혈', 
    '공격 시 공속 증가', '골드 획득량 20% 증가', '빙결 확률 5%', '화상 확률 5%', '스킬 쿨감 1초'
];

const WEAPON_DATA = {
    '맨손':  {t:'p', r:50,  d:0.8, s:2.5, p:0, e:{type:'rect',w:50,h:20,c:'rgba(255,255,255,0.4)', shape: 'fist'}},
    '단검':  {t:'h', r:80,  d:1.1, s:3, p:0, e:{type:'rect',w:90,h:12,c:'rgba(180,180,180,0.7)', shape: 'dagger'}},
    '검':    {t:'s', r:140, d:3, s:1.5, p:0, e:{type:'arc',c:'rgba(200,200,255,0.8)', shape: 'sword'}},
    '창':    {t:'h', r:160, d:2.0, s:0.5, p:1, e:{type:'rect',w:170,h:15,c:'rgba(220,220,180,0.7)', shape: 'spear'}},
    '도끼':  {t:'m', r:130, d:8.5, s:0.3, p:1, e:{type:'arc',c:'rgba(255,100,100,0.8)', shape: 'axe'}},
    '망치':  {t:'m', r:150, d:9.5, s:0.25,p:0, e:{type:'arc',c:'rgba(150,150,150,0.8)', shape: 'hammer'}},
    '활':    {t:'r', v:18,  d:6.0, s:1.1, p:0, life:1000, e:{c:'#f1c40f', shape: 'arrow'}},
    '석궁':  {t:'r', v:16,  d:1.4, s:0.2, p:1, life:1200, e:{c:'#e67e22', shape: 'arrow'}},
    '지팡이':{t:'g', v:10,  d:0.7, s:0.5, p:1, life:1500, e:{count:3,spread:0.15,c:'#9b59b6', shape: 'magic_bolt'}},
    '철퇴':  {t:'m', r:130, d:3.3, s:0.28, p:1, e:{type:'arc',c:'rgba(192,192,192,0.8)', shape: 'hammer'}},
    '카타르':{t:'h', r:90,  d:1.4, s:2.4, p:0, e:{type:'rect',w:100,h:15,c:'rgba(120,200,200,0.7)', shape: 'dagger'}},
    '장궁':  {t:'r', v:22,  d:10, s:0.85,p:0, life:1500, e:{c:'#3498db', shape: 'arrow'}},
    '마법총':{t:'g', r: 100, v:20,  d:0.3, s:10, p:0, life:900, e:{count:1,c:'#e74c3c', shape: 'magic_bolt'}},
    '글레이브':{t:'s', r:180, d:1.1, s:1.5, p:1, e:{type:'arc',c:'rgba(46,204,113,0.8)', shape: 'spear'}},
    '전투 낫':{t:'m', r:200, d:6, s:0.27, p:1, e:{type:'arc',c:'rgba(142,68,173,0.8)', shape: 'axe'}}
};

const ARMOR_DATA = { '가죽 갑옷': {}, '사슬 갑옷': {}, '강철 갑옷': {}, '철판 흉갑': {}, '미스릴 갑옷': {}, '용비늘 갑옷': {}, '암흑 갑옷': {}, '수호신의 갑옷': {}, '광휘의 갑옷': {}, '타락한 심장의 갑주': {} };

const SKILL_DATA = {
    '메테오': {type:'aoe', r:120, d:2.5, cd:10, c:'rgba(255,100,0,0.7)', name:'메테오'},
    '연쇄 번개': {type:'chain', t:4, d:0.8, cd:6, c:'rgba(100,100,255,0.8)', name:'연쇄 번개'},
    '칼날 폭풍': {type:'aura', r:180, d:0.3, dur:5, tick:0.25, cd:12, c:'rgba(200,200,200,0.5)', name:'칼날 폭풍'},
    '치유의 빛': {type:'heal', a:0.3, cd:15, c:'rgba(100,255,100,0.8)', name:'치유의 빛'},
    '빙결': {type:'aoe', r:100, d:0.5, cd:8, c:'rgba(100,200,255,0.6)', frz:2, name:'빙결'},
    '독 안개': {type:'aura_poison', r:150, d:0.2, dur:8, tick:0.5, cd:10, c:'rgba(100,255,100,0.4)', name:'독 안개'},
    '보호막': {type:'shield', dur:5, cd:20, val:0.3, name:'보호막'},
    '광폭화': {type:'rage', dur:8, cd:18, val:0.5, name:'광폭화'},
    '흡혈 저주': {type:'aoe_dot', r:100, d:0.2, dur:6, tick:0.5, cd:12, c:'rgba(192,57,43,0.6)', name:'흡혈 저주'},
    '지진': {type:'earthquake', r:200, d:1.5, dur:4, cd:15, val:0.5, c:'rgba(139,69,19,0.6)', name:'지진'},
    '눈보라': {type:'blizzard', r:200, d:0.1, dur:6, tick:1, cd:20, frz:0.5, c:'rgba(224,255,255,0.5)', name:'눈보라'},
    '암살': {type:'assassinate', d:5, cd:8, name:'암살'},
    '신성 폭발': {type:'holy_blast', r:150, d:1.0, a:0.2, cd:18, c:'rgba(255,215,0,0.6)', name:'신성 폭발'},
    '시간 왜곡': {type:'time_warp', dur:5, cd:30, val:0.5, name:'시간 왜곡'},
    '피의 갈증': {type:'blood_thirst', r:180, dur:7, tick:0.2, d:0.25, val:0.1, cd:16, c:'rgba(255,0,0,0.4)', name:'피의 갈증'},
    '천상의 방패': {type:'divine_shield', dur:3, cd:40, name:'천상의 방패'}
};

const TALENT_DATA = {
    '공격': { name: '공격', talents: [
        {id:'atk1', name:'기초 훈련', desc:'공격력 +10%', cost:1},
        {id:'atk2', name:'치명상 연구', desc:'치명타 피해 +30%', cost:2, prereq:'atk1'},
        {id:'atk3', name:'약점 포착', desc:'치명타 확률 +5%', cost:2, prereq:'atk2'},
        {id:'atk4', name:'무기 전문가', desc:'모든 무기 피해 +15%', cost:3, prereq:'atk3'},
        {id:'atk5', name:'결정타', desc:'치명타 시 10% 확률로 2배 피해', cost:4, prereq:'atk4'},
        {id:'atk6', name:'파괴자', desc:'공격력 +25%', cost:4, prereq:'atk5'},
        {id:'atk7', name:'학살자', desc:'적 처치 시 5초간 공격력 +20%', cost:5, prereq:'atk6'},
        {id:'atk8', name:'전쟁의 신', desc:'공격력 +20%, 치명타 확률 +10%', cost:6, prereq:'atk7'},
        {id:'atk9', name:'광란', desc:'적 처치 시 5초간 공격속도 +10%', cost: 7, prereq: 'atk8'},
        {id:'atk10', name:'필멸의 일격', desc:'공격 시 10% 확률로 체력 15% 이하의 일반 몬스터 즉사', cost: 8, prereq: 'atk9'}
    ]},
    '방어': { name: '방어', talents: [
        {id:'def1', name:'기초 훈련', desc:'최대 체력 +15%', cost:1},
        {id:'def2', name:'강철 피부', desc:'방어력 +20%', cost:2, prereq:'def1'},
        {id:'def3', name:'재생력', desc:'초당 체력 0.5% 재생', cost:3, prereq:'def2'},
        {id:'def4', name:'불굴', desc:'받는 피해 10% 감소', cost:3, prereq:'def3'},
        {id:'def5', name:'강철의 의지', desc:'피격 시 5초간 방어력 +30%', cost:4, prereq:'def4'},
        {id:'def6', name:'회피', desc:'받는 피해 10% 확률로 무시', cost:4, prereq:'def5'},
        {id:'def7', name:'수호자', desc:'최대 체력 +30%, 방어력 +30%', cost:5, prereq:'def6'},
        {id:'def8', name:'불멸자', desc:'받는 피해 15% 감소, 초당 체력 1% 재생', cost:6, prereq:'def7'},
        {id:'def9', name:'응급 처치', desc:'체력 30% 이하일 때 60초마다 최대 체력의 20% 회복', cost: 7, prereq: 'def8'},
        {id:'def10', name:'신의 가호', desc:'30초마다 모든 피해를 1회 막는 보호막 획득', cost: 8, prereq: 'def9'}
    ]},
    '유틸': { name: '유틸', talents: [
        {id:'util1', name:'신속', desc:'공격 속도 +10%', cost:1},
        {id:'util2', name:'지혜', desc:'경험치 획득량 +20%', cost:2, prereq:'util1'},
        {id:'util3', name:'마력 제어', desc:'스킬 쿨다운 -10%', cost:3, prereq:'util2'},
        {id:'util4', name:'효과 증폭', desc:'스킬 효과(지속,범위) +20%', cost:3, prereq:'util3'},
        {id:'util5', name:'연금술', desc:'물약 및 회복 효과 +25%', cost:4, prereq:'util4'},
        {id:'util6', name:'시간 가속', desc:'공격 속도 +15%, 쿨다운 -15%', cost:4, prereq:'util5'},
        {id:'util7', name:'마력 폭주', desc:'스킬 사용 시 5% 확률로 쿨타임 초기화', cost:5, prereq:'util6'},
        {id:'util8', name:'현자', desc:'모든 스킬 레벨 +1 효과', cost:6, prereq:'util7'},
        {id:'util9', name:'마나 순환', desc:'적 처치 시 10% 확률로 모든 스킬 쿨다운 1초 감소', cost: 7, prereq: 'util8'},
        {id:'util10', name:'초월자', desc:'모든 스킬 쿨다운 추가 15% 감소, 버프 지속시간 25% 증가', cost: 8, prereq: 'util9'}
    ]},
    '탐욕': { name: '탐욕', talents: [
        {id:'greed1', name:'협상가', desc:'골드 획득량 +20%', cost:1},
        {id:'greed2', name:'보물 사냥꾼', desc:'토큰 드롭 확률 +15%', cost:2, prereq:'greed1'},
        {id:'greed3', name:'행운', desc:'상위 등급 아이템 드롭 확률 증가', cost:3, prereq:'greed2'},
        {id:'greed4', name:'황금 손길', desc:'적 처치 시 5% 확률로 10배 골드 획득', cost:3, prereq:'greed3'},
        {id:'greed5', name:'계약', desc:'강화 비용 20% 감소', cost:4, prereq:'greed4'},
        {id:'greed6', name:'약탈', desc:'공격 시 1% 확률로 적에게서 골드 훔침', cost:4, prereq:'greed5'},
        {id:'greed7', name:'탐욕의 왕', desc:'골드/토큰 획득량 +30%', cost:5, prereq:'greed6'},
        {id:'greed8', name:'보물왕', desc:'층 클리어 시 추가 보상 획득', cost:6, prereq:'greed7'},
        {id:'greed9', name:'장비 복제', desc:'갸챠 시 5% 확률로 동일 아이템 추가 획득', cost: 7, prereq: 'greed8'},
        {id:'greed10', name:'황금의 신', desc:'골드 획득량 +50%, 적이 갸챠 토큰을 직접 드롭할 확률 2%', cost: 8, prereq: 'greed9'}
    ]},
    '특수': { name: '특수', talents: [
        {id:'spec1', name:'흡혈', desc:'주는 피해의 2%만큼 체력 회복', cost:2},
        {id:'spec2', name:'반사', desc:'받는 피해의 10%를 적에게 반사', cost:2, prereq:'spec1'},
        {id:'spec3', name:'죽음의 저항', desc:'죽음에 이르는 피해 시 1회 생존', cost:3, prereq:'spec2'},
        {id:'spec4', name:'처형인', desc:'체력 20% 이하 적에게 피해 +50%', cost:4, prereq:'spec3'},
        {id:'spec5', name:'역병', desc:'공격 시 5초간 적 방어력 10% 감소', cost:4, prereq:'spec4'},
        {id:'spec6', name:'초월', desc:'모든 스탯 +15%', cost:5, prereq:'spec5'},
        {id:'spec7', name:'지배자', desc:'엘리트/보스에게 주는 피해 +25%', cost:5, prereq:'spec6'},
        {id:'spec8', name:'파멸', desc:'모든 피해량 20% 증가, 받는 피해 10% 증가', cost:6, prereq:'spec7'},
        {id:'spec9', name:'절대 영점', desc:'공격 시 5% 확률로 2초간 적을 빙결시키고 받는 피해 20% 증가', cost: 7, prereq: 'spec8'},
        {id:'spec10', name:'운명 조작', desc:'모든 확률 기반 효과 발동 확률 +5%', cost: 8, prereq: 'spec9'}
    ]},
    '전사': { name: '전사', job: true, talents: [
        {id:'job_war1', name:'검기', desc:'근접 공격 적중 시 전방으로 검기 발사 (공격력 50%)', cost:2},
        {id:'job_war2', name:'강인함', desc:'최대 체력 +25%, 공격 속도 -10%', cost:2, prereq:'job_war1'},
        {id:'job_war3', name:'분노', desc:'치명타 피해 +50%', cost:3, prereq:'job_war2'},
        {id:'job_war4', name:'무기 연마', desc:'검/도끼/망치 계열 무기 공격력 +30%', cost:4, prereq:'job_war3'},
        {id:'job_war5', name:'광전사', desc:'적 처치 시 10% 확률로 광폭화 스킬 쿨타임 초기화', cost:5, prereq:'job_war4'},
    ]},
    '마법사': { name: '마법사', job: true, talents: [
        {id:'job_mage1', name:'마력 증폭', desc:'모든 스킬의 공격력 +25%', cost:2},
        {id:'job_mage2', name:'원소 연구', desc:'독, 화상 등 상태이상 피해 +30%', cost:2, prereq:'job_mage1'},
        {id:'job_mage3', name:'마나 순환', desc:'스킬 쿨타임 20% 감소', cost:3, prereq:'job_mage2'},
        {id:'job_mage4', name:'마력 보호막', desc:'피격 시 15% 확률로 3초간 최대체력 10% 보호막 생성', cost:4, prereq:'job_mage3'},
        {id:'job_mage5', name:'대마법사', desc:'모든 스킬의 범위와 지속시간 +25%', cost:5, prereq:'job_mage4'},
    ]}
};

const SKILL_UPGRADE_DATA = {
    '메테오': {
        5: [
            { id: 'dmg_up_1', name: '피해량 +25%', apply: (d) => ({...d, d: d.d * 1.25}) },
            { id: 'cd_down_1', name: '쿨타임 -15%', apply: (d) => ({...d, cd: d.cd * 0.85}) },
            { id: 'range_up_1', name: '범위 +20%', apply: (d) => ({...d, r: d.r * 1.20}) },
        ],
        10: [
            { id: 'dmg_up_2', name: '피해량 +35%', apply: (d) => ({...d, d: d.d * 1.35}) },
            { id: 'meteor_shower', name: '메테오 2개 추가 낙하', apply: (d) => ({...d, count: (d.count || 1) + 2}) },
            { id: 'burn_chance', name: '30% 확률로 5초간 화상 부여', apply: (d) => ({...d, burn: {chance: 0.3, duration: 5000}}) }
        ]
    },
    '연쇄 번개': {
        5: [
            { id: 'dmg_up_1', name: '피해량 +20%', apply: (d) => ({...d, d: d.d * 1.20}) },
            { id: 'cd_down_1', name: '쿨타임 -10%', apply: (d) => ({...d, cd: d.cd * 0.90}) },
            { id: 'chain_up_1', name: '최대 타겟 +2', apply: (d) => ({...d, t: d.t + 2}) },
        ],
        10: [
            { id: 'dmg_up_2', name: '피해량 +30%', apply: (d) => ({...d, d: d.d * 1.30}) },
            { id: 'stun_chance', name: '마지막 타격 시 50% 확률로 1초 기절', apply: (d) => ({...d, stun: {chance: 0.5, duration: 1000}}) },
            { id: 'killReset_chance', name: '적 처치 시 15% 확률로 쿨타임 초기화', apply: (d) => ({...d, killReset: 0.15}) },
        ]
    },
    '칼날 폭풍': {
        5: [
            { id: 'dmg_up_1', name: '틱당 피해량 +20%', apply: (d) => ({...d, d: d.d * 1.20}) },
            { id: 'duration_up_1', name: '지속시간 +2초', apply: (d) => ({...d, dur: d.dur + 2}) },
            { id: 'range_up_1', name: '범위 +15%', apply: (d) => ({...d, r: d.r * 1.15}) },
        ],
        10: [
            { id: 'dmg_up_2', name: '피해량 +30%', apply: (d) => ({...d, d: d.d * 1.30}) },
            { id: 'lifesteal', name: '피해량의 15% 흡혈', apply: (d) => ({...d, lifesteal: 0.15}) },
            { id: 'wider_storm', name: '범위 +25%, 지속시간 +2초', apply: (d) => ({...d, r: d.r * 1.25, dur: d.dur + 2}) },
        ]
    },
    '치유의 빛': {
        5: [
            { id: 'heal_up_1', name: '치유량 +25%', apply: (d) => ({...d, a: d.a * 1.25}) },
            { id: 'cd_down_1', name: '쿨타임 -15%', apply: (d) => ({...d, cd: d.cd * 0.85}) },
            { id: 'hot', name: '5초간 추가로 최대 체력의 10% 회복', apply: (d) => ({...d, hot: {percent: 0.1, duration: 5000}}) }
        ],
        10: [
            { id: 'heal_up_2', name: '치유량 +40%', apply: (d) => ({...d, a: d.a * 1.40}) },
            { id: 'purify', name: '모든 상태이상 해제', apply: (d) => ({...d, purify: true}) },
            { id: 'sacred_ground', name: '5초간 초당 최대체력 5% 회복 장판 생성', apply: (d) => ({...d, ground_heal: {percent: 0.05, duration: 5000}}) }
        ]
    },
    '빙결': {
        5: [
            { id: 'dmg_up_1', name: '피해량 +25%', apply: (d) => ({...d, d: d.d * 1.25}) },
            { id: 'cd_down_1', name: '쿨타임 -15%', apply: (d) => ({...d, cd: d.cd * 0.85}) },
            { id: 'freeze_duration_1', name: '빙결 시간 +1초', apply: (d) => ({...d, frz: d.frz + 1}) }
        ],
        10: [
            { id: 'dmg_up_2', name: '피해량 +35%', apply: (d) => ({...d, d: d.d * 1.35}) },
            { id: 'vulnerable', name: '빙결된 적 받는 피해 +20%', apply: (d) => ({...d, vulnerable: 1.2}) },
            { id: 'chill', name: '빙결 풀린 적 3초간 둔화', apply: (d) => ({...d, chill: {duration: 3000, slow: 0.5}}) }
        ]
    },
    '독 안개': {
        5: [
            { id: 'dmg_up_1', name: '틱당 피해량 +25%', apply: (d) => ({...d, d: d.d * 1.25}) },
            { id: 'duration_up_1', name: '지속시간 +3초', apply: (d) => ({...d, dur: d.dur + 3}) },
            { id: 'range_up_1', name: '범위 +20%', apply: (d) => ({...d, r: d.r * 1.2}) }
        ],
        10: [
            { id: 'dmg_up_2', name: '틱당 피해량 +40%', apply: (d) => ({...d, d: d.d * 1.4}) },
            { id: 'neurotoxin', name: '독 걸린 적 공속 -20%', apply: (d) => ({...d, neurotoxin: 0.2}) },
            { id: 'acid_mist', name: '독 걸린 적 방어력 -15%', apply: (d) => ({...d, acid: 0.15}) }
        ]
    },
    '보호막': {
        5: [
            { id: 'shield_up_1', name: '흡수량 +30%', apply: (d) => ({...d, val: d.val * 1.3}) },
            { id: 'duration_up_1', name: '지속시간 +2초', apply: (d) => ({...d, dur: d.dur + 2}) },
            { id: 'cd_down_1', name: '쿨타임 -15%', apply: (d) => ({...d, cd: d.cd * 0.85}) }
        ],
        10: [
            { id: 'shield_explode', name: '보호막 파괴 시 폭발 피해', apply: (d) => ({...d, explode: true}) },
            { id: 'reflect_shield', name: '보호막 중 피격시 30% 반사', apply: (d) => ({...d, reflect: 0.3}) },
            { id: 'recharge', name: '보호막 지속 중 초당 10% 회복', apply: (d) => ({...d, recharge: 0.1}) }
        ]
    },
    '광폭화': {
        5: [
            { id: 'atk_up_1', name: '공격력 증가량 +20%', apply: (d) => ({...d, val: d.val * 1.2}) },
            { id: 'duration_up_1', name: '지속시간 +3초', apply: (d) => ({...d, dur: d.dur + 3}) },
            { id: 'cd_down_1', name: '쿨타임 -15%', apply: (d) => ({...d, cd: d.cd * 0.85}) }
        ],
        10: [
            { id: 'atk_up_2', name: '공격력 증가량 +30%', apply: (d) => ({...d, val: d.val * 1.3}) },
            { id: 'merciless', name: '적 처치 시 지속시간 +1초', apply: (d) => ({...d, merciless: true}) },
            { id: 'blood_pact', name: '받는 피해 +10%, 공속 추가 +25%', apply: (d) => ({...d, blood_pact: {dmg_inc: 1.1, as_inc: 1.25}}) }
        ]
    },
     '흡혈 저주': {
        5: [
            { id: 'dmg_up_1', name: '틱당 피해 +25%', apply: (d) => ({...d, d: d.d * 1.25}) },
            { id: 'lifesteal_up_1', name: '흡혈량 +20%', apply: (d) => ({...d, lifesteal_mod: (d.lifesteal_mod||1) * 1.2}) },
            { id: 'range_up_1', name: '범위 +20%', apply: (d) => ({...d, r: d.r * 1.2}) }
        ],
        10: [
            { id: 'dmg_up_2', name: '틱당 피해 +40%', apply: (d) => ({...d, d: d.d * 1.4}) },
            { id: 'spread', name: '저주로 죽은 적 주변에 전염', apply: (d) => ({...d, spread: true}) },
            { id: 'pain_amp', name: '저주 걸린 적 받는 피해 +10%', apply: (d) => ({...d, pain_amp: 1.1}) }
        ]
    },
    '지진': {
        5: [
            { id: 'dmg_up_1', name: '피해량 +25%', apply: (d) => ({...d, d: d.d * 1.25}) },
            { id: 'stun_duration_1', name: '기절 시간 +1초', apply: (d) => ({...d, stun_dur: (d.stun_dur||2) + 1}) },
            { id: 'range_up_1', name: '범위 +20%', apply: (d) => ({...d, r: d.r * 1.2}) }
        ],
        10: [
            { id: 'dmg_up_2', name: '피해량 +40%', apply: (d) => ({...d, d: d.d * 1.4}) },
            { id: 'aftershock', name: '지진 후 3초간 둔화 장판 생성', apply: (d) => ({...d, aftershock: {duration: 3000, slow: 0.5}}) },
            { id: 'crack', name: '맞은 적 방어력 -30%', apply: (d) => ({...d, crack: 0.3}) }
        ]
    },
    '눈보라': {
        5: [
            { id: 'dmg_up_1', name: '틱당 피해 +25%', apply: (d) => ({...d, d: d.d * 1.25}) },
            { id: 'duration_up_1', name: '지속시간 +2초', apply: (d) => ({...d, dur: d.dur + 2}) },
            { id: 'freeze_chance_1', name: '빙결 확률 +10%', apply: (d) => ({...d, frz_chance: (d.frz_chance||0) + 0.1}) }
        ],
        10: [
            { id: 'dmg_up_2', name: '틱당 피해 +40%', apply: (d) => ({...d, d: d.d * 1.4}) },
            { id: 'absolute_zero', name: '중심부의 적 완전 빙결', apply: (d) => ({...d, absolute_zero: true}) },
            { id: 'frostbite', name: '맞은 적 공속 -30%', apply: (d) => ({...d, frostbite: 0.3}) }
        ]
    },
    '암살': {
        5: [
            { id: 'dmg_up_1', name: '피해량 +30%', apply: (d) => ({...d, d: d.d * 1.3}) },
            { id: 'cd_down_1', name: '쿨타임 -20%', apply: (d) => ({...d, cd: d.cd * 0.8}) },
            { id: 'range_up_1', name: '시전 거리 +30%', apply: (d) => ({...d, range_mod: (d.range_mod||1) * 1.3}) }
        ],
        10: [
            { id: 'dmg_up_2', name: '피해량 +50%', apply: (d) => ({...d, d: d.d * 1.5}) },
            { id: 'execute', name: '잃은 체력 1%당 피해 0.5% 증가', apply: (d) => ({...d, execute: 0.005}) },
            { id: 'chain_kill', name: '처치 시 3초 내 재사용 가능', apply: (d) => ({...d, chain_kill: true}) }
        ]
    },
    '신성 폭발': {
        5: [
            { id: 'dmg_up_1', name: '피해량 +25%', apply: (d) => ({...d, d: d.d * 1.25}) },
            { id: 'heal_up_1', name: '치유량 +25%', apply: (d) => ({...d, a: d.a * 1.25}) },
            { id: 'range_up_1', name: '범위 +20%', apply: (d) => ({...d, r: d.r * 1.2}) }
        ],
        10: [
            { id: 'dmg_up_2', name: '피해량 +40%', apply: (d) => ({...d, d: d.d * 1.4}) },
            { id: 'blind', name: '50% 확률로 2초간 실명', apply: (d) => ({...d, blind: {chance: 0.5, duration: 2000}}) },
            { id: 'consecration', name: '5초간 아군 공격력 +15% 장판', apply: (d) => ({...d, consecration: {duration: 5000, power: 0.15}}) }
        ]
    },
    '시간 왜곡': {
        5: [
            { id: 'amp_1', name: '효과 증폭 +20%', apply: (d) => ({...d, val: d.val * 1.2}) },
            { id: 'duration_up_1', name: '지속시간 +2초', apply: (d) => ({...d, dur: d.dur + 2}) },
            { id: 'cd_down_1', name: '쿨타임 -15%', apply: (d) => ({...d, cd: d.cd * 0.85}) }
        ],
        10: [
            { id: 'amp_2', name: '효과 증폭 +30%', apply: (d) => ({...d, val: d.val * 1.3}) },
            { id: 'warp_zone', name: '주변 펫에게도 효과 적용', apply: (d) => ({...d, warp_zone: true}) },
            { id: 'time_stop', name: '시전 시 1초간 모든 적 정지', apply: (d) => ({...d, time_stop: 1000}) }
        ]
    },
    '피의 갈증': {
        5: [
            { id: 'dmg_up_1', name: '피해량 +25%', apply: (d) => ({...d, d: d.d * 1.25}) },
            { id: 'lifesteal_up_1', name: '흡혈량 +25%', apply: (d) => ({...d, val: d.val * 1.25}) },
            { id: 'duration_up_1', name: '지속시간 +2초', apply: (d) => ({...d, dur: d.dur + 2}) }
        ],
        10: [
            { id: 'dmg_up_2', name: '피해량 +40%', apply: (d) => ({...d, d: d.d * 1.4}) },
            { id: 'blood_explosion', name: '종료 시 추가 피해 및 회복', apply: (d) => ({...d, explosion: true}) },
            { id: 'frenzy', name: '지속 중 공속 +20%', apply: (d) => ({...d, frenzy: 1.2}) }
        ]
    },
    '천상의 방패': {
        5: [
            { id: 'duration_up_1', name: '지속시간 +1초', apply: (d) => ({...d, dur: d.dur + 1}) },
            { id: 'cd_down_1', name: '쿨타임 -15%', apply: (d) => ({...d, cd: d.cd * 0.85}) },
            { id: 'divine_wrath', name: '무적 중 초당 신성 피해', apply: (d) => ({...d, wrath_dps: 0.5}) }
        ],
        10: [
            { id: 'duration_up_2', name: '지속시간 +2초', apply: (d) => ({...d, dur: d.dur + 2}) },
            { id: 'cd_down_2', name: '쿨타임 -20%', apply: (d) => ({...d, cd: d.cd * 0.8}) },
            { id: 'last_stand', name: '무적 해제 시 잃은 체력 20% 회복', apply: (d) => ({...d, last_stand: 0.2}) }
        ]
    }
};

const JOB_SKILL_DATA = {
    '전사': [
        { name: '회전격', type: 'aura', r: 150, d: 2.0, dur: 1, tick: 0.2, cd: 8, c: 'rgba(255, 80, 80, 0.5)' },
        { name: '전장의 함성', type: 'rage', dur: 5, cd: 20, val: 0.3, name:'전장의 함성' }
    ],
    '마법사': [
        { name: '원소 구체', type: 'projectile_skill', d: 1.5, cd: 6, c: 'rgba(150, 100, 255, 0.8)', v: 4, life: 2500, p: true },
        { name: '차원 이동', type: 'teleport', range: 300, cd: 10, c: 'rgba(150, 100, 255, 0.8)' }
    ]
};

const STATUS_EFFECTS = { POISON: 'poison', BURN: 'burn', FREEZE: 'freeze', STUN: 'stun', VULNERABLE: 'vulnerable', SLOW: 'slow' };

class Particle {
    constructor(x, y, color, size, speed, life) { this.x = x; this.y = y; this.color = color; this.size = size; this.life = life; this.maxLife = life; this.vx = speed * (Math.random() - 0.5) * 2; this.vy = speed * (Math.random() - 0.5) * 2; }
    update(dt) { this.life -= dt; this.x += this.vx * (dt / 1000); this.y += this.vy * (dt / 1000); this.vy += 50 * (dt / 1000); }
    draw(ctx) { ctx.save(); ctx.globalAlpha = this.life / this.maxLife; ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
}

class Enemy {
    constructor(game, isElite) { this.game = game; this.id = Math.random(); this.isElite = isElite; this.x = game.canvas.width + 50 + Math.random() * 200; this.size = isElite ? 30 : 18; this.y = game.groundY - this.size; const floorMultiplier = Math.pow(1.18, game.currentFloor - 1); this.maxHp = Math.floor((30 + game.currentFloor * 15) * (isElite ? 3.0 : 1) * floorMultiplier); this.hp = this.maxHp; this.damage = Math.floor((10 + Math.max(1,(Math.round(game.currentFloor ** 1/2)) * 2)) * (isElite ? 2.2 : 1) * floorMultiplier); this.speed = (60 + game.currentFloor * 10) * (isElite ? 0.9 : 1) * Math.min(floorMultiplier * 0.8, 3); this.lastAttackTime = 0; this.statusEffects = new Map(); this.isFrozen = false; this.isStunned = false; }
    update(dt, player, dealDamageCallback) {
        this.updateStatusEffects(dt);
        let currentSpeed = this.speed;
        if (this.statusEffects.has(STATUS_EFFECTS.SLOW)) {
            currentSpeed *= (1 - this.statusEffects.get(STATUS_EFFECTS.SLOW).value);
        }
        if (this.isFrozen || this.isStunned) return;
        const dx = player.x - this.x;
        if (Math.abs(dx) > this.size) {
            const moveAmount = currentSpeed * (dt / 1000);
            if (dx > 0) { // player is to the right
                this.x = Math.min(this.x + moveAmount, player.x);
            } else { // player is to the left
                this.x = Math.max(this.x - moveAmount, player.x);
            }
        }
        if (Math.abs(dx) < this.size + player.size + 10 && Date.now() - this.lastAttackTime > 1800) { this.lastAttackTime = Date.now(); dealDamageCallback(Math.floor(this.damage)); }
    }
    updateStatusEffects(dt) { for (let [effect, data] of this.statusEffects) { data.duration -= dt; if (data.tick) { data.tick -= dt; if (data.tick <= 0) { let dotDamageMultiplier = 1; if(this.game.talents['job_mage2']) { dotDamageMultiplier = 1.3; } switch(effect) { case STATUS_EFFECTS.POISON: this.takeDamage(this.game.dealDamage(this, Math.floor(this.maxHp * 0.02 * dotDamageMultiplier), null, true)); this.game.createFloatingText('독!', this.x, this.y - 20, '138,43,226', 16); break; case STATUS_EFFECTS.BURN: this.takeDamage(this.game.dealDamage(this, Math.floor(this.maxHp * 0.03 * dotDamageMultiplier), null, true)); this.game.createFloatingText('화상!', this.x, this.y - 20, '231,76,60', 16); break; } data.tick = data.tickInterval; } } if (data.duration <= 0) { this.statusEffects.delete(effect); if (effect === STATUS_EFFECTS.FREEZE) this.isFrozen = false; if (effect === STATUS_EFFECTS.STUN) this.isStunned = false; } } }
    applyStatusEffect(effect, duration, tickInterval = 1000, value = 0) {
        this.statusEffects.set(effect, { duration, tick: tickInterval, tickInterval, value });
        if (effect === STATUS_EFFECTS.FREEZE) this.isFrozen = true;
        if (effect === STATUS_EFFECTS.STUN) this.isStunned = true;
    }
    draw(ctx) { ctx.save(); if (this.isElite) { ctx.shadowBlur = 15; ctx.shadowColor = '#e74c3c'; } if (this.isFrozen) ctx.fillStyle = '#3498db'; else if (this.isStunned) ctx.fillStyle = '#f39c12'; else if (this.statusEffects.has(STATUS_EFFECTS.POISON)) ctx.fillStyle = '#8e44ad'; else if (this.statusEffects.has(STATUS_EFFECTS.BURN)) ctx.fillStyle = '#e67e22'; else ctx.fillStyle = this.isElite ? '#e74c3c' : '#c0392b'; if(this.statusEffects.has(STATUS_EFFECTS.SLOW)) { ctx.shadowBlur = 10; ctx.shadowColor = '#bdc3c7'; } ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); const bw = 50, bx = this.x - bw / 2, by = this.y - this.size - 15; ctx.fillStyle = '#333'; ctx.fillRect(bx, by, bw, 6); ctx.fillStyle = this.hp > this.maxHp * 0.3 ? '#2ecc71' : '#e74c3c'; ctx.fillRect(bx, by, bw * (this.hp / this.maxHp), 6); if (this.isElite) { ctx.fillStyle = '#ffd700'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('★', this.x, this.y - this.size - 25); } ctx.restore(); }
    takeDamage(d) { this.hp -= d; }
}

class BaseEffect {
    constructor(g, dur){this.game = g; this.life = dur; this.maxLife = dur; this.isDone = false;}
    update(dt){this.life -= dt; if(this.life <= 0) this.isDone = true;}
    draw(ctx){}
}

class MeleeEffect extends BaseEffect {
    constructor(g, w_item) {
        super(g, 200);
        this.p = g.player; this.w_item = w_item; this.w_data = WEAPON_DATA[w_item.name]; this.hit = new Set();
        this.dmg = this.p.attackPower; const rarityBonus = Object.keys(RARITY_DATA).indexOf(w_item.rarity) * 0.1;
        this.a = { x: this.p.x, y: this.p.y, t: this.w_data.e.type, r: this.w_data.r * (1 + rarityBonus) };
        if (this.a.t === 'rect') { this.a.w = this.w_data.e.w * (1 + rarityBonus); this.a.h = this.w_data.e.h; } 
        else if (this.a.t === 'arc') { this.startAngle = -0.8; this.endAngle = 0.8; }
        this.checkHits();
    }
    checkHits(){ this.game.enemies.forEach(e => { if(this.hit.has(e.id)) return; if(this.isColliding(e)){ this.game.dealDamage(e, this.dmg, this.w_item); this.hit.add(e.id); if(this.game.talents['job_war1']) { const angle = Math.atan2(e.y - this.p.y, e.x - this.p.x); const p_item = {name: '검기', rarity: this.w_item.rarity}; const p_data = {life: 500, p: true, d: 0.5, e: {shape: 'sword'}}; const p_dmg = this.p.attackPower * 0.5; this.game.projectiles.push(new Projectile(this.game, 'player', p_item, this.p.x, this.p.y, Math.cos(angle) * 15 * 30, Math.sin(angle) * 15 * 30, p_data, p_dmg)); } if(!this.w_data.p) this.isDone = true; } }); this.game.particles.push(...Array(15).fill(0).map(() => new Particle(this.p.x + this.a.r / 2, this.p.y, '#fff', Math.random() * 4 + 2, 120, 600))); }
    isColliding(e){ if(this.a.t === 'arc'){ const dx = e.x - this.a.x, dy = e.y - this.a.y; return Math.hypot(dx, dy) < this.a.r + e.size; } else if(this.a.t === 'rect'){ const rx = this.a.x + 10, ry = this.a.y - this.a.h / 2; const dx = Math.abs(e.x - rx - this.a.w / 2), dy = Math.abs(e.y - ry - this.a.h / 2); if(dx > this.a.w / 2 + e.size || dy > this.a.h / 2 + e.size) return false; if(dx <= this.a.w / 2 || dy <= this.a.h / 2) return true; return (dx - this.a.w / 2)**2 + (dy - this.a.h / 2)**2 <= e.size**2; } return false; }
    draw(ctx){
        const prog = 1 - this.life / this.maxLife;
        const weaponColor = RARITY_DATA[this.w_item.rarity].c;
        const shape = this.w_data.e.shape || 'sword';

        ctx.save();
        ctx.translate(this.p.x, this.p.y);

        if (this.a.t === 'arc' || this.w_data.t === 'm' || this.w_data.t === 's') {
            const angle = (prog * Math.PI) - (Math.PI / 2);
            drawWeaponShapes(ctx, shape, 0, 0, angle, 1.2, weaponColor, this.w_item.rarity);
        } else if (this.w_data.t === 'h') {
            const xOffset = 50 * prog;
            drawWeaponShapes(ctx, shape, xOffset, 0, 0, 1.2, weaponColor, this.w_item.rarity);
        } else { // fist
            ctx.globalAlpha = Math.sin(prog * Math.PI);
            ctx.fillStyle = this.w_data.e.c;
            ctx.fillRect(10, -this.w_data.e.h / 2, this.w_data.e.w, this.w_data.e.h);
        }
        ctx.restore();
    }
}

class Projectile extends BaseEffect {
    constructor(game, owner, item, startX, startY, vx, vy, overrideWeaponData = null, overrideDamage = null) {
        const weaponData = overrideWeaponData || WEAPON_DATA[item.name];
        super(game, weaponData.life || 1000);
        this.owner = owner;
        this.item = item;
        this.weaponData = weaponData;
        this.x = startX;
        this.y = startY;
        this.vx = vx;
        this.vy = vy;
        this.pierce = weaponData.p;
        this.damage = overrideDamage || (game.player.attackPower * weaponData.d);
        this.angle = Math.atan2(vy, vx);
        this.rarityIndex = Object.keys(RARITY_DATA).indexOf(item.rarity);
        this.trail = [];
        this.hitEnemies = new Set();
    }

    update(dt) {
        super.update(dt);
        this.x += this.vx * (dt / 1000);
        this.y += this.vy * (dt / 1000);
        
        if (this.rarityIndex >= 3) {
            if(this.trail.length === 0 || Math.hypot(this.x - this.trail[this.trail.length - 1].x, this.y - this.trail[this.trail.length - 1].y) > 10) {
                 this.trail.push({x: this.x, y: this.y, life: 10});
            }
        }
        for(let i = this.trail.length - 1; i >= 0; i--) {
            this.trail[i].life--;
            if (this.trail[i].life <= 0) this.trail.splice(i, 1);
        }

        if (this.x > this.game.canvas.width + 50 || this.x < -50 || this.y > this.game.canvas.height + 50 || this.y < -50) {
            this.isDone = true;
        }
    }

    draw(ctx) {
        if (this.trail.length > 1) {
             ctx.save();
             const rarityColor = RARITY_DATA[this.item.rarity].c;
             ctx.strokeStyle = rarityColor;
             ctx.lineWidth = 2 + this.rarityIndex;
             ctx.globalAlpha = 0.4;
             ctx.beginPath();
             ctx.moveTo(this.trail[0].x, this.trail[0].y);
             for(let i = 1; i < this.trail.length; i++) {
                 ctx.lineTo(this.trail[i].x, this.trail[i].y);
             }
             ctx.stroke();
             ctx.restore();
        }
        
        const shape = this.weaponData.e.shape || 'magic_bolt';
        const color = RARITY_DATA[this.item.rarity].c;
        drawWeaponShapes(ctx, shape, this.x, this.y, this.angle, 1, color, this.item.rarity);
    }
}

class SkillEffect extends BaseEffect {
    constructor(g, p, s, s_item){
        super(g, s.dur ? s.dur * 1000 : 300);
        this.p = p; this.s = s; this.s_item = s_item; this.x = g.mouse.x; this.y = g.mouse.y; 
        this.dmg = this.p.attackPower * (this.s.d || 1); 
        if (g.talents['job_mage1']) { this.dmg *= 1.25; }
        this.tick = 0; this.hit = new Set(); this.activate();
    }
    activate(){
        switch(this.s.type){
            case 'teleport':
                const angle_tp = Math.atan2(this.game.mouse.y - this.p.y, this.game.mouse.x - this.p.x);
                const dist = Math.min(this.s.range, Math.hypot(this.game.mouse.x - this.p.x, this.game.mouse.y - this.p.y));
                this.p.x += Math.cos(angle_tp) * dist;
                this.p.x = Math.max(this.p.size, Math.min(this.game.canvas.width - this.p.size, this.p.x));
                this.p.y = this.game.groundY - this.p.size;
                this.game.particles.push(...Array(30).fill(0).map(() => new Particle(this.p.x, this.p.y, this.s.c, Math.random() * 4 + 2, 200, 800)));
                break;
            case 'projectile_skill':
                const angle = Math.atan2(this.game.mouse.y - this.p.y, this.game.mouse.x - this.p.x);
                const p_item = {name: this.s.name, rarity: 'L'}; // Job skills are legendary
                const p_data = {life: this.s.life, p: this.s.p, d: this.s.d, e: {shape: 'magic_bolt'}};
                const vx = Math.cos(angle) * this.s.v * 30;
                const vy = Math.sin(angle) * this.s.v * 30;
                this.game.projectiles.push(new Projectile(this.game, 'player', p_item, this.p.x, this.p.y, vx, vy, p_data, this.dmg));
                break;
            case 'aoe':
                const meteorCount = this.s.count || 1;
                for (let i = 0; i < meteorCount; i++) {
                    const offsetX = (i > 0) ? (Math.random() - 0.5) * (this.s.r || 100) * 0.7 : 0;
                    const offsetY = (i > 0) ? (Math.random() - 0.5) * (this.s.r || 100) * 0.7 : 0;
                    const currentX = this.x + offsetX;
                    const currentY = this.y + offsetY;
                    this.game.enemies.forEach(e => {
                        if (Math.hypot(currentX - e.x, currentY - e.y) < this.s.r) {
                            const killed = this.game.dealDamage(e, this.dmg, null);
                            if (this.s.frz) e.applyStatusEffect(STATUS_EFFECTS.FREEZE, this.s.frz * 1000);
                            if (this.s.burn && Math.random() < this.s.burn.chance) {
                                e.applyStatusEffect(STATUS_EFFECTS.BURN, this.s.burn.duration, 1000);
                            }
                        }
                    });
                    this.game.particles.push(...Array(40).fill(0).map(() => new Particle(currentX, currentY, this.s.c, Math.random() * 6 + 3, 250, 1000)));
                }
                break;
            case 'chain':
                let t = null, lastTarget = null;
                for(let i = 0; i < this.s.t; i++){
                    const nt = this.findClosest(t ? t.x : this.p.x, t ? t.y : this.p.y);
                    if(nt){
                        const killed = this.game.dealDamage(nt, this.dmg, null);
                        if (killed && this.s.killReset && Math.random() < this.s.killReset) {
                            const skillSlot = this.game.equipment.skills.findIndex(sk => sk && sk.id === this.s_item.id);
                            if (skillSlot > -1) {
                                this.game.player.skillCooldowns[skillSlot] = 0;
                                this.game.createNotification(`${this.s.name} 쿨타임 초기화!`, 'success');
                            }
                        }
                        this.hit.add(nt.id);
                        t = nt;
                        lastTarget = nt;
                        this.game.particles.push(...Array(10).fill(0).map(() => new Particle(nt.x, nt.y, this.s.c, Math.random() * 4 + 2, 150, 800)));
                    } else break;
                }
                if (this.s.stun && lastTarget && Math.random() < this.s.stun.chance) {
                    lastTarget.applyStatusEffect(STATUS_EFFECTS.STUN, this.s.stun.duration);
                }
                break;
            case 'heal':
                const h = this.p.maxHp * this.s.a; this.p.hp = Math.min(this.p.maxHp, this.p.hp + h);
                this.game.createFloatingText(`+${Math.ceil(h)}`, this.p.x, this.p.y, '100,255,100', 24);
                this.game.particles.push(...Array(20).fill(0).map(() => new Particle(this.p.x, this.p.y, 'rgba(100,255,100,0.8)', Math.random() * 4 + 2, 100, 1000)));
                 if (this.s.hot) {
                    const totalHeal = this.p.maxHp * this.s.hot.percent;
                    const amountPerSecond = totalHeal / (this.s.hot.duration / 1000);
                    this.p.hots.push({ amountPerSecond, duration: this.s.hot.duration });
                }
                if (this.s.purify) {
                    this.p.statusEffects.clear();
                    this.game.createFloatingText(`정화!`, this.p.x, this.p.y - 20, '#3498db', 20);
                }
                break;
            case 'shield': this.p.shieldAmount = Math.floor(this.p.maxHp * this.s.val); this.p.shieldDuration = this.s.dur * 1000; this.game.createFloatingText('보호막!', this.p.x, this.p.y, '52,152,219', 20); break;
            case 'rage': this.p.rageMultiplier = 1 + this.s.val; this.p.rageDuration = this.s.dur * 1000; this.game.createFloatingText('광폭화!', this.p.x, this.p.y, '231,76,60', 20); break;
            case 'earthquake': this.game.enemies.forEach(e => { if(Math.hypot(this.x - e.x, this.y - e.y) < this.s.r){ this.game.dealDamage(e, this.dmg, null); e.applyStatusEffect(STATUS_EFFECTS.STUN, 2000); } }); this.game.createFloatingText('지진!', this.x, this.y, '139,69,19', 24); this.game.particles.push(...Array(60).fill(0).map(() => new Particle(this.x + (Math.random() - 0.5) * this.s.r, this.y, this.s.c, Math.random() * 8 + 4, 200, 1500))); break;
            case 'assassinate': const cE = this.findClosest(this.p.x, this.p.y); if(cE && Math.hypot(this.p.x - cE.x, this.p.y - cE.y) < 250){ this.game.dealDamage(cE, this.dmg * (1 + (this.p.critRate / 100) * this.p.critDamage), null); this.game.createFloatingText('암살!', cE.x, cE.y, '255,50,50', 24); this.game.particles.push(...Array(30).fill(0).map(() => new Particle(cE.x, cE.y, 'rgba(255,50,50,0.8)', Math.random() * 6 + 3, 250, 1000))); } break;
            case 'holy_blast': this.game.enemies.forEach(e => { if(Math.hypot(this.x - e.x, this.y - e.y) < this.s.r){ this.game.dealDamage(e, this.dmg, null); } }); const hA2 = this.p.maxHp * this.s.a; this.p.hp = Math.min(this.p.maxHp, this.p.hp + hA2); this.game.createFloatingText(`신성 폭발! +${Math.ceil(hA2)}`, this.x, this.y, '255,215,0', 20); this.game.particles.push(...Array(50).fill(0).map(() => new Particle(this.x, this.y, this.s.c, Math.random() * 6 + 3, 300, 1200))); break;
            case 'time_warp': this.p.timeWarpMultiplier = 1 + this.s.val; this.p.timeWarpDuration = this.s.dur * 1000; this.game.createFloatingText('시간 왜곡!', this.p.x, this.p.y, '138,43,226', 20); break;
            case 'divine_shield': this.p.invulnerable = true; this.p.invulnerableDuration = this.s.dur * 1000; this.game.createFloatingText('무적!', this.p.x, this.p.y, '255,215,0', 24); break;
        }
    }
    findClosest(x, y, e = []){ let c = null, mD = Infinity; this.game.enemies.forEach(en => { if(e.some(ex => ex && ex.id === en.id) || this.hit.has(en.id)) return; const d = Math.hypot(x - en.x, y - en.y); if(d < mD){ mD = d; c = en; } }); return c; }
    update(dt){ super.update(dt); if(['aura', 'aura_poison', 'blizzard', 'blood_thirst', 'divine_shield'].includes(this.s.type)){ this.tick -= dt; if(this.tick <= 0){ this.tick = (this.s.tick || 1) * 1000; this.game.enemies.forEach(e => { if (Math.hypot(this.p.x - e.x, this.p.y - e.y) < this.s.r) { const damage = this.p.attackPower * (this.s.d || 0); if (this.s.type === 'divine_shield' && this.s.wrath_dps) { this.game.dealDamage(e, this.p.attackPower * this.s.wrath_dps, null, true); } else if (damage > 0) { const killed = this.game.dealDamage(e, damage, null); if(this.s.type === 'aura_poison') {e.applyStatusEffect(STATUS_EFFECTS.POISON, 3000);} if(this.s.type === 'blizzard') { if (Math.random() < (this.s.frz_chance || 0)) { e.applyStatusEffect(STATUS_EFFECTS.FREEZE, this.s.frz * 1000); } } if(this.s.type === 'blood_thirst') { const l = Math.ceil(damage * this.s.val); this.p.hp = Math.min(this.p.maxHp, this.p.hp + l); } if (this.s.lifesteal) { this.p.hp = Math.min(this.p.maxHp, this.p.hp + Math.ceil(damage * this.s.lifesteal)); } } } }); } } }
    draw(ctx){ ctx.save(); ctx.globalAlpha = Math.max(0, this.life / this.maxLife); ctx.fillStyle = this.s.c || 'rgba(255,255,255,0.5)'; ctx.shadowBlur = 20; ctx.shadowColor = this.s.c || '#fff'; if(this.s.type.includes('aoe') || this.s.type.includes('aura') || ['earthquake', 'blizzard', 'holy_blast'].includes(this.s.type)){ const x = ['aura', 'aura_poison', 'blizzard', 'blood_thirst', 'divine_shield'].includes(this.s.type) ? this.p.x : this.x; const y = ['aura', 'aura_poison', 'blizzard', 'blood_thirst', 'divine_shield'].includes(this.s.type) ? this.p.y : this.y; ctx.beginPath(); ctx.arc(x, y, this.s.r || 100, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); }
}

class Game {
    constructor(){ this.canvas = document.getElementById('gameCanvas'); this.ctx = this.canvas.getContext('2d'); this.timeScale = 1.0; this.init(); }
    init(isRestart = false){
        this.isGameOver = false; this.canvas.width = 1280; this.canvas.height = 720; this.groundY = this.canvas.height - 80;
        this.resetPlayerState();
        this.enemies = []; this.projectiles = []; this.activeEffects = []; this.floatingTexts = []; this.particles = [];
        this.currentFloor = 1; this.currentWave = 1; this.totalWaves = 5; this.inventoryFilter = 'all'; this.floorCompleted = false;
        this.pityCounter = 100; this.keys = {}; this.mouse = {x:0, y:0, isDown:false}; this.lastAttackTime = 0; this.skillEquipSlot = -1;
        this.activeSkillForUpgrade = null;
        this.activePet = null;
        this.synthesisSlots = [null, null, null];
        this.isSelectingForSynth = false;
        this.synthSelectionSlot = -1;
        
        ['inventoryPanel', 'gachaPanel', 'talentPanel', 'petPanel', 'synthesisPanel'].forEach(id => document.getElementById(id).style.display = 'none');
        this.closeModal('gameOverScreen');
        this.resume();
        
        if (!this.eventListenersAttached) { this.setupEventListeners(); this.eventListenersAttached = true; }
        if (!isRestart) { this.loadGame(); }
        
        document.getElementById('ui').style.display = 'block';
        this.spawnWave(); this.updateStats(); this.updateUI(); this.initTalentTree();
        if (!this.gameLoopRunning || isRestart) { this.lastFrameTime = performance.now(); this.gameLoop(); }
    }
    resetPlayerState(){
        this.player = { 
            x: 200, y: this.canvas.height - 80 - 20, size: 20, hp: 100, maxHp: 100, defense: 0, level: 1, exp: 0, expToNext: 100,
            gold: 1000, gachaTokens: 500, baseAttackPower: 5, attackPower: 5, critRate: 0.05, critDamage: 1.5,
            skillCooldowns: [0, 0, 0, 0], shieldAmount: 0, shieldDuration: 0, rageMultiplier: 1, rageDuration: 0, 
            timeWarpMultiplier: 1, timeWarpDuration: 0, invulnerable: false, invulnerableDuration: 0,
            hots: [], petCubes: 10, attackSpeedBuff: 0, attackSpeedBuffDuration: 0,
            advancementPoints: 0, job: null, jobSkillCooldowns: [0,0]
        };
        this.equipment = {weapon: null, armor: null, skills: [null, null, null, null], pet: null, jobSkills: [null, null]}; 
        this.inventory = []; this.talents = {}; this.talentPoints = 0;
        this.pets = [];
        this.openPanels = [];
    }
    setupEventListeners(){
        const kh = (e, v) => { 
            this.keys[e.key.toLowerCase()] = v; 
            if(v) {
                if(e.key >= '1' && e.key <= '4') this.useSkill(parseInt(e.key) - 1);
                if(e.key.toLowerCase() === 'q') this.useJobSkill(0);
                if(e.key.toLowerCase() === 'w') this.useJobSkill(1);
            }
        };
        window.addEventListener('keydown', e => kh(e, true)); window.addEventListener('keyup', e => kh(e, false));
        this.canvas.addEventListener('mousemove', e => { const r = this.canvas.getBoundingClientRect(); this.mouse.x = e.clientX - r.left; this.mouse.y = e.clientY - r.top; });
        this.canvas.addEventListener('mousedown', () => { this.mouse.isDown = true; }); this.canvas.addEventListener('mouseup', () => { this.mouse.isDown = false; });
        this.canvas.addEventListener('click', () => this.attack());
        const buttons = { gacha1Button: () => this.performGacha(1), gacha10Button: () => this.performGacha(10), petGacha1Button: () => this.performPetGacha(1), closeInventoryButton: () => this.closeView('inventoryPanel'), openGachaButton: () => this.openView('gachaPanel'), closeGachaButton: () => this.closeView('gachaPanel'), openTalentButton: () => this.openView('talentPanel'), closeTalentButton: () => this.closeView('talentPanel'), openInventoryButton: () => this.openView('inventoryPanel'), openPetButton: () => this.openView('petPanel'), closePetButton: () => this.closeView('petPanel'), restartButton: () => this.init(true), nextFloorButton: () => this.nextFloor(), openSynthesisButton: () => this.openView('synthesisPanel'), closeSynthesisButton: () => this.closeView('synthesisPanel'), synthesizeButton: () => this.synthesizeItems(), resetGameButton: () => this.gameOver() };
        Object.entries(buttons).forEach(([id, func]) => document.getElementById(id).addEventListener('click', func));
        document.getElementById('inventoryFilter').addEventListener('click', e => { if(e.target.dataset.filter) this.filterInventory(e.target.dataset.filter); });
        document.getElementById('weaponArea').addEventListener('click', () => this.openView('inventoryPanel', 'weapon'));
        document.getElementById('armorArea').addEventListener('click', () => this.openView('inventoryPanel', 'armor'));
        document.getElementById('petArea').addEventListener('click', () => this.openView('petPanel'));
        document.getElementById('synthesisSlotsContainer').addEventListener('click', e => {
            if (e.target.closest('.synthesis-slot')) {
                const slotIndex = parseInt(e.target.closest('.synthesis-slot').dataset.slot, 10);
                this.selectSynthItem(slotIndex);
            }
        });
        setInterval(() => { if(!this.isGameOver) this.saveGame(); }, 5000);
        window.addEventListener('beforeunload', () => this.saveGame());
    }
    pause() { this.timeScale = 0; document.getElementById('pauseIndicator').innerText = ""; document.getElementById('pauseIndicator').style.display = 'block'; }
    resume() { this.timeScale = 1; document.getElementById('pauseIndicator').style.display = 'none'; }
    gameLoop(){
        this.gameLoopRunning = true; if(this.isGameOver) { this.gameLoopRunning = false; return; }
        const n = performance.now(); const dt = (n - (this.lastFrameTime || n)) * this.timeScale;
        this.lastFrameTime = n; this.update(dt); this.draw();
        requestAnimationFrame(() => this.gameLoop());
    }
    update(dt){
        if(this.keys['a'] || this.keys['arrowleft']) this.player.x -= 300 * (dt / 1000);
        if(this.keys['d'] || this.keys['arrowright']) this.player.x += 300 * (dt / 1000);
        this.player.x = Math.max(this.player.size, Math.min(this.canvas.width - this.player.size, this.player.x));
        this.player.skillCooldowns = this.player.skillCooldowns.map(cd => Math.max(0, cd - dt));
        this.player.jobSkillCooldowns = this.player.jobSkillCooldowns.map(cd => Math.max(0, cd - dt));
        this.updatePlayerBuffs(dt);
        this.applyTalentEffects(dt);
        for(let key of ['activeEffects', 'projectiles', 'enemies', 'particles', 'floatingTexts']){
            for(let i = this[key].length - 1; i >= 0; i--){
                const item = this[key][i]; if(item.update) item.update(dt, this.player, dmg => this.takeDamage(dmg));
                if(key === 'floatingTexts'){ item.life -= dt; item.alpha = Math.max(0, item.life / 2000); item.y -= 60 * (dt / 1000); if(item.life <= 0 || item.alpha <= 0) this[key].splice(i, 1); }
                else if(item.isDone || item.life <= 0) { this[key].splice(i, 1); }
            }
        }
        if (this.activePet) this.activePet.update(dt);
        this.handleCollisions();
        if(this.enemies.length === 0 && !this.floorCompleted){ if(this.currentWave < this.totalWaves){ this.currentWave++; this.spawnWave(); } else { this.completeFloor(); } }
        this.updateUI();
    }
    updatePlayerBuffs(dt) {
        if (this.player.shieldDuration > 0) { this.player.shieldDuration -= dt; if (this.player.shieldDuration <= 0) this.player.shieldAmount = 0; }
        if (this.player.rageDuration > 0) { this.player.rageDuration -= dt; if (this.player.rageDuration <= 0) this.player.rageMultiplier = 1; }
        if (this.player.timeWarpDuration > 0) { this.player.timeWarpDuration -= dt; if (this.player.timeWarpDuration <= 0) this.player.timeWarpMultiplier = 1; }
        if (this.player.invulnerableDuration > 0) { this.player.invulnerableDuration -= dt; if (this.player.invulnerableDuration <= 0) this.player.invulnerable = false; }
        if (this.player.attackSpeedBuffDuration > 0) { this.player.attackSpeedBuffDuration -= dt; if(this.player.attackSpeedBuffDuration <= 0) this.player.attackSpeedBuff = 0; }
        for (let i = this.player.hots.length - 1; i >= 0; i--) {
            const hot = this.player.hots[i];
            this.player.hp = Math.min(this.player.maxHp, this.player.hp + hot.amountPerSecond * (dt / 1000));
            hot.duration -= dt;
            if (hot.duration <= 0) {
                this.player.hots.splice(i, 1);
            }
        }
    }
    applyTalentEffects(dt) { if(this.talents['def3']) { const rA = this.player.maxHp * 0.005 * (dt / 1000); this.player.hp = Math.min(this.player.maxHp, this.player.hp + rA); } if(this.talents['def8']) { const rA = this.player.maxHp * 0.01 * (dt / 1000); this.player.hp = Math.min(this.player.maxHp, this.player.hp + rA); } }
    handleCollisions(){
        this.enemies.forEach(e => {
            for(let i = this.projectiles.length - 1; i >= 0; i--) {
                const p = this.projectiles[i];
                if (p.hitEnemies.has(e.id)) continue;

                if(Math.hypot(p.x - e.x, p.y - e.y) < e.size){
                    this.dealDamage(e, p.damage, p.item);
                    p.hitEnemies.add(e.id);

                    if(!p.pierce) {
                         this.projectiles.splice(i, 1);
                    }
                }
            }
        });
    }
    draw(){
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        const g = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height); g.addColorStop(0, '#2c3e50'); g.addColorStop(1, '#34495e'); this.ctx.fillStyle = g; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fillStyle = '#4a524a'; this.ctx.fillRect(0, this.groundY, this.canvas.width, this.canvas.height - this.groundY);
        for(let k of ['activeEffects', 'particles', 'projectiles', 'enemies']){ this[k].forEach(i => i.draw(this.ctx)); }
        if(this.activePet) this.activePet.draw(this.ctx);
        
        if (this.mouse.isDown) {
            const weaponItem = this.equipment.weapon || { name: '맨손', rarity: 'N' };
            const w = WEAPON_DATA[weaponItem.name];
            const rarityBonus = weaponItem.rarity ? Object.keys(RARITY_DATA).indexOf(weaponItem.rarity) * 0.1 : 0;
            this.ctx.save();
            this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([5, 5]);
            this.ctx.beginPath();
            if (w.t === 'r' || w.t === 'g') {
                const range = w.r || 500; // 원거리 무기 사거리 기본값
                this.ctx.arc(this.player.x, this.player.y, range * (1 + rarityBonus), 0, Math.PI * 2);
            } else {
                const range = w.r * (1 + rarityBonus);
                if (w.e.type === 'arc') {
                    this.ctx.arc(this.player.x, this.player.y, range, -0.8, 0.8);
                } else if (w.e.type === 'rect') {
                    this.ctx.rect(this.player.x + 10, this.player.y - w.e.h/2, w.e.w * (1 + rarityBonus), w.e.h);
                }
            }
            this.ctx.stroke();
            this.ctx.restore();
        }

        this.ctx.save(); this.ctx.shadowBlur = 10; this.ctx.shadowColor = '#3498db'; if (this.player.invulnerable) { this.ctx.shadowColor = '#ffd700'; this.ctx.fillStyle = '#ffd700'; } else if (this.player.shieldAmount > 0) { this.ctx.shadowColor = '#3498db'; this.ctx.fillStyle = '#3498db'; } else if (this.player.rageMultiplier > 1) { this.ctx.shadowColor = '#e74c3c'; this.ctx.fillStyle = '#e74c3c'; } else { this.ctx.fillStyle = '#3498db'; } this.ctx.beginPath(); this.ctx.arc(this.player.x, this.player.y, this.player.size, 0, 2 * Math.PI); this.ctx.fill(); this.ctx.restore();
        this.floatingTexts.forEach(t => { this.ctx.fillStyle = `rgba(${t.c}, ${t.alpha})`; this.ctx.font = `bold ${t.s}px 'Noto Sans KR'`; this.ctx.strokeStyle = 'rgba(0,0,0,0.8)'; this.ctx.lineWidth = 3; this.ctx.strokeText(t.text, t.x, t.y); this.ctx.fillText(t.text, t.x, t.y); });
    }
    
    attack(){
        const wI = this.equipment.weapon || {name: '맨손', rarity: 'N'}; const w = WEAPON_DATA[wI.name];
        let aS = this.getAttackSpeed();
        if(Date.now() - this.lastAttackTime < 1000 / aS) return; this.lastAttackTime = Date.now();
        if(w.t === 'r' || w.t === 'g'){ const c = w.e.count || 1; const angle = Math.atan2(this.mouse.y - this.player.y, this.mouse.x - this.player.x); for(let i = 0; i < c; i++){ const sA = angle + (i - (c - 1) / 2) * (w.e.spread || 0); this.projectiles.push(new Projectile(this, 'player', wI, this.player.x, this.player.y, Math.cos(sA) * w.v * 30, Math.sin(sA) * w.v * 30)); }
        } else { this.activeEffects.push(new MeleeEffect(this, wI)); }
    }
    
    useSkill(i){
        const s = this.equipment.skills[i]; if(!s || this.player.skillCooldowns[i] > 0) return;
        const d = this.getModifiedSkillData(s);
        let cd = d.cd;
        if(this.talents['util3']) cd *= 0.9; if(this.talents['util6']) cd *= 0.85; if (this.talents['util10']) cd *= 0.85;
        if(this.talents['job_mage3']) cd *= 0.8;
        this.player.skillCooldowns[i] = cd * 1000;
        if(this.talents['util7'] && Math.random() < 0.05) { this.player.skillCooldowns[i] = 0; this.createNotification('마력 폭주! 쿨타임 초기화!', 'success'); }
        this.activeEffects.push(new SkillEffect(this, this.player, d, s));
        this.gainSkillExp(s, 5);
    }
    
    useJobSkill(i) {
        const s = this.equipment.jobSkills[i];
        if (!s || this.player.jobSkillCooldowns[i] > 0) return;
        const d = s;
        let cd = d.cd;
        if(this.talents['util3']) cd *= 0.9;
        if(this.talents['util6']) cd *= 0.85;
        if(this.talents['util10']) cd *= 0.85;
        if(this.talents['job_mage3']) cd *= 0.8;
        this.player.jobSkillCooldowns[i] = cd * 1000;
        if(this.talents['util7'] && Math.random() < 0.05) {
            this.player.jobSkillCooldowns[i] = 0;
            this.createNotification('마력 폭주! 쿨타임 초기화!', 'success');
        }
        this.activeEffects.push(new SkillEffect(this, this.player, d, s));
    }
    
    dealDamage(e, d, weaponItem = this.equipment.weapon, isStatusEffect = false){
        if(isStatusEffect) { e.takeDamage(d); return false; }
        
        let finalDamage = d;
        if (weaponItem && weaponItem.name) { const wd = WEAPON_DATA[weaponItem.name]; if (wd) { finalDamage *= wd.d; } }
        
        finalDamage *= this.player.rageMultiplier;
        
        if (this.talents['spec4'] && e.hp / e.maxHp <= 0.2) finalDamage *= 1.5;
        if (this.talents['spec7'] && e.isElite) finalDamage *= 1.25;
        if (this.talents['spec8']) finalDamage *= 1.2;
        if (e.statusEffects.has(STATUS_EFFECTS.VULNERABLE)) finalDamage *= 1.2;
        
        let critChance = this.player.critRate;
        if(this.talents['spec10']) critChance += 0.05;

        const isCrit = Math.random() < critChance;
        if (isCrit) {
            finalDamage *= this.player.critDamage;
            if (this.talents['atk5'] && Math.random() < 0.1) { finalDamage *= 2; this.createFloatingText('결정타!', e.x, e.y - 20, '255,50,50', 24); }
        }
        
        finalDamage = Math.max(1, Math.floor(finalDamage));
        e.takeDamage(finalDamage);
        
        this.createFloatingText(`-${finalDamage}`, e.x, e.y, isCrit ? '255,100,0' : '255,200,50', isCrit ? 24 : 20);
        
        if (this.talents['spec1']) { this.player.hp = Math.min(this.player.maxHp, this.player.hp + Math.ceil(finalDamage * 0.02)); }
        if (this.talents['spec2']) { const rD = Math.floor(d * 0.1); e.takeDamage(rD); }
        if(weaponItem && weaponItem.special === '흡혈 10%'){ this.player.hp = Math.min(this.player.maxHp, this.player.hp + Math.ceil(finalDamage * 0.1)); }
        if (this.talents['spec9'] && Math.random() < 0.05) { e.applyStatusEffect(STATUS_EFFECTS.FREEZE, 2000); e.applyStatusEffect(STATUS_EFFECTS.VULNERABLE, 2000); }
        
        if(e.hp <= 0) {
            this.killEnemy(e, weaponItem);
            return true;
        }
        return false;
    }
    
    killEnemy(e, w){
        if(w && w.special === '처치 시 폭발'){ this.activeEffects.push(new SkillEffect(this, this.player, {type: 'aoe', r: 80, d: 0.5, c: 'rgba(255,150,50,0.6)'})); }
        this.enemies = this.enemies.filter(en => en.id !== e.id); let eG = e.isElite ? 80 : 30; if(this.talents['util2']) eG *= 1.2; this.gainExp(eG);
        let gG = (e.isElite ? 40 : 15) * this.currentFloor;
        if(this.talents['greed1']) gG *= 1.2; if(this.talents['greed7']) gG *= 1.3; if(this.talents['greed4'] && Math.random() < 0.05) gG *= 10;
        this.player.gold += Math.floor(gG);
        let tC = 0.3; if(this.talents['greed2']) tC += 0.15; if(this.talents['greed7']) tC += 0.3; if (this.talents['greed10'] && Math.random() < 0.02) tC = 1;
        if(Math.random() < tC) this.player.gachaTokens += Math.ceil(this.currentFloor / 5) + 1;
        if(this.talents['atk7']) { this.player.tempAttackBonus = (this.player.tempAttackBonus || 0) + 0.2; setTimeout(() => { this.player.tempAttackBonus -= 0.2; this.updateStats(); }, 5000); this.updateStats(); }
        if(this.talents['util9'] && Math.random() < 0.1) { this.player.skillCooldowns = this.player.skillCooldowns.map(cd => Math.max(0, cd - 1000)); }
        if (this.talents['job_war5'] && w?.name === '광폭화' && Math.random() < 0.1) {
            const rageSkillSlot = this.equipment.skills.findIndex(s => s && s.name === '광폭화');
            if (rageSkillSlot > -1) {
                this.player.skillCooldowns[rageSkillSlot] = 0;
                this.createNotification('광폭화 쿨타임 초기화!', 'success');
            }
        }
    }
    
    takeDamage(d){
        if (this.player.invulnerable) return;
        if (this.player.divineShieldCharges > 0) { this.player.divineShieldCharges--; this.createFloatingText('신의 가호!', this.player.x, this.player.y, '#ffd700', 24); return; }
        
        let finalDamage = d;
        if (this.player.shieldAmount > 0) { const damageToShield = Math.min(this.player.shieldAmount, finalDamage); this.player.shieldAmount -= damageToShield; finalDamage -= damageToShield; }
        
        finalDamage -= this.player.defense; 
        if(this.talents['def4']) finalDamage *= 0.9; if(this.talents['def8']) finalDamage *= 0.85; if(this.talents['spec8']) finalDamage *= 1.1;
        
        let dodgeChance = 0; if (this.talents['def6']) dodgeChance += 0.1; if (this.talents['spec10']) dodgeChance += 0.05;
        if(Math.random() < dodgeChance) { this.createFloatingText('회피!', this.player.x, this.player.y, '100,255,255', 24); return; }
        
        if (this.talents['job_mage4'] && Math.random() < 0.15) {
            this.player.shieldAmount = Math.max(this.player.shieldAmount, this.player.maxHp * 0.1);
            this.player.shieldDuration = 3000;
            this.createFloatingText('마력 보호막!', this.player.x, this.player.y, '#9b59b6', 20);
        }

        finalDamage = Math.max(1, finalDamage);
        
        this.player.hp -= finalDamage; 
        this.createFloatingText(`-${Math.floor(finalDamage)}`, this.player.x, this.player.y, '255,50,50', 26);
        
        if(this.player.hp <= 0) {
            if(this.talents['spec3'] && !this.player.usedDeathResist) { this.player.hp = 1; this.player.usedDeathResist = true; this.createFloatingText('죽음의 저항!', this.player.x, this.player.y - 30, '255,215,0', 30); }
            else { this.gameOver(); }
        }
    }
    
    levelUp(){
        this.player.level++; this.player.exp = 0; this.player.expToNext = Math.floor(100 * (1.2**this.player.level));
        this.player.maxHp += 20; this.player.hp = this.player.maxHp; this.player.baseAttackPower += 2;
        let pG = this.player.level <= 10 ? 1 : (this.player.level <= 25 ? 2 : 3); this.talentPoints += pG;
        if (this.player.level === 10) {
            this.player.advancementPoints++;
            this.createNotification('전직 가능! 특성창을 확인하세요', 'success');
        }
        this.updateStats(); this.createNotification(`레벨 업! 특성 포인트 +${pG}`, 'success'); this.initTalentTree();
    }
    
    gainExp(a){ this.player.exp += a; if(this.player.exp >= this.player.expToNext) this.levelUp(); }
    
    rollGacha(){
        let r = 'N';
        if(--this.pityCounter <= 0) { const hR = ['SSR','UR','L','U','SU','SSU','M','LM','EN','G']; r = hR[Math.floor(Math.random() * hR.length)]; this.pityCounter = 100; } 
        else { const rand = Math.random(); let cum = 0; for(const [k, d] of Object.entries(RARITY_DATA)) { cum += d.r; if(rand < cum) { r = k; break; } } }
        const tR = Math.random(); let type, nP;
        if(tR < 0.45) { type = 'weapon'; nP = Object.keys(WEAPON_DATA).filter(n => n !== '맨손'); }
        else if(tR < 0.8) { type = 'armor'; nP = Object.keys(ARMOR_DATA); }
        else { type = 'skill'; nP = Object.keys(SKILL_DATA); }
        const name = nP[Math.floor(Math.random() * nP.length)];
        const nI = { id: `${Date.now()}${Math.random()}`, name: name, type: type, rarity: r, level: 0, power: Math.floor(5 * RARITY_DATA[r].p) };
        if(type === 'weapon' || type === 'armor') {
            nI.star = 0;
        }
        if(type === 'skill') {
            nI.level = 1;
            nI.exp = 0;
            nI.expToNext = 15;
            nI.upgrades = [];
        }
        if(Object.keys(RARITY_DATA).indexOf(r) >= 4 && type === 'weapon') { nI.special = SSR_WEAPON_SPECIALS[Math.floor(Math.random() * SSR_WEAPON_SPECIALS.length)]; }
        return nI;
    }
    
    enhanceItem(id){
        const i = this.inventory.find(it => it.id === id); if(!i || i.level >= 10) return;
        let c = Math.floor(150 * Math.pow(2.3, i.level)); if(this.talents['greed5']) c = Math.floor(c * 0.8);
        if(this.player.gold < c){ this.createNotification('골드가 부족합니다!', 'error'); return; }
        this.player.gold -= c; const sR = Math.pow(0.5, i.level);
        if(Math.random() < sR){ i.level++; i.power = Math.floor(i.power * 1.3); this.createNotification(`(+${i.level}) ${i.name} 강화 성공!`, 'success'); }
        else { this.createNotification('강화 실패...', 'error'); }
        this.updateStats(); this.updateInventoryDisplay();
    }
    
    updateStats(){
        const w = this.equipment.weapon, a = this.equipment.armor;
        let w_power = 0;
        if (w) w_power = (w.power || 0) * (1 + (w.star || 0) * 0.2);
        let a_power = 0;
        if (a) a_power = (a.power || 0) * (1 + (a.star || 0) * 0.2);

        let bA = (this.player.baseAttackPower || 5) + w_power;
        let bH = 100 + (this.player.level - 1) * 20; 
        let bD = a_power;

        // Warrior Talent
        if (w && this.talents['job_war4']) {
            const meleeWeapons = ['검', '도끼', '망치', '철퇴', '전투 낫'];
            if(meleeWeapons.includes(w.name)) bA *= 1.3;
        }

        if(this.talents['atk1']) bA *= 1.1; if(this.talents['atk6']) bA *= 1.25; if(this.talents['atk8']) bA *= 1.2;
        if(this.talents['def1']) bH *= 1.15; if(this.talents['def2']) bD *= 1.2; if(this.talents['def7']) { bH *= 1.3; bD *= 1.3; }
        if(this.talents['job_war2']) bH *= 1.25;
        if(this.talents['spec6']) { bA *= 1.15; bH *= 1.15; bD *= 1.15; }
        bA *= (1 + (this.player.tempAttackBonus || 0));
        this.player.attackPower = Math.floor(bA); 
        this.player.defense = Math.floor(bD); 
        this.player.maxHp = Math.floor(bH);
        
        let critRate = 0.05; if(this.talents['atk3']) critRate += 0.05; if(this.talents['atk8']) critRate += 0.1; this.player.critRate = critRate;
        let critDmg = 1.5; if(this.talents['atk2']) critDmg += 0.3; if(this.talents['job_war3']) critDmg += 0.5; this.player.critDamage = critDmg;
        
        if(this.player.hp > this.player.maxHp) this.player.hp = this.player.maxHp; 
        this.updateUI();
    }
    
    startSkillEquip(slotIndex) { this.skillEquipSlot = slotIndex; this.openView('inventoryPanel', 'skill'); this.createNotification(`${slotIndex + 1}번 슬롯에 장착할 스킬을 선택하세요.`, 'info'); }
    equipSkill(item) { if (this.skillEquipSlot === -1 || item.type !== 'skill') return; if (this.equipment.skills.some(s => s && s.id === item.id)) { this.createNotification('이미 다른 슬롯에 장착된 스킬입니다.', 'error'); return; } this.equipment.skills[this.skillEquipSlot] = item; this.createNotification(`${item.name} 스킬을 ${this.skillEquipSlot + 1}번에 장착했습니다.`, 'success'); this.skillEquipSlot = -1; this.closeView('inventoryPanel'); this.updateUI(); }
    
    getModifiedSkillData(skillItem) {
        if (!skillItem) return null;
        let modifiedData = { ...SKILL_DATA[skillItem.name] };
        
        // Talent mods
        if(this.talents['job_mage5']) {
            if(modifiedData.r) modifiedData.r *= 1.25;
            if(modifiedData.dur) modifiedData.dur *= 1.25;
        }

        const upgradeMaster = SKILL_UPGRADE_DATA[skillItem.name];
        if (upgradeMaster && skillItem.upgrades && skillItem.upgrades.length > 0) {
            skillItem.upgrades.forEach(upgradeId => {
                let foundUpgrade = null;
                Object.values(upgradeMaster).forEach(levelUpgrades => {
                    const upgrade = levelUpgrades.find(opt => opt.id === upgradeId);
                    if (upgrade) foundUpgrade = upgrade;
                });

                if (foundUpgrade && foundUpgrade.apply) {
                    modifiedData = foundUpgrade.apply(modifiedData);
                }
            });
        }
        
        modifiedData.d *= (1 + (skillItem.level - 1) * 0.05);
        return modifiedData;
    }

    gainSkillExp(skillItem, amount) {
        if (!skillItem) return;
        const itemInInventory = this.inventory.find(invItem => invItem.id === skillItem.id);
        if (!itemInInventory) return;
        
        itemInInventory.exp += amount;
        this.createFloatingText(`+${amount}xp`, this.player.x, this.player.y - 50, '200,200,255', 14);

        if (itemInInventory.exp >= itemInInventory.expToNext) {
            this.skillLevelUp(itemInInventory);
        }
        this.updateUI();
    }

    skillLevelUp(item) {
        item.level++;
        item.exp -= item.expToNext;
        item.expToNext = Math.floor(15 * Math.pow(1.5, item.level - 1));
        this.createNotification(`${item.name} 스킬 레벨 업! (Lv.${item.level})`, 'success');

        const upgradeInfo = SKILL_UPGRADE_DATA[item.name];
        if (upgradeInfo && upgradeInfo[item.level]) {
            this.openSkillUpgradeModal(item);
        }
    }
    
    openSkillUpgradeModal(item) {
        this.pause();
        this.activeSkillForUpgrade = item; 

        const upgradeInfo = SKILL_UPGRADE_DATA[item.name];
        const optionsForLevel = upgradeInfo ? upgradeInfo[item.level] : null;

        if (!optionsForLevel) {
            this.resume();
            return;
        }
        
        document.getElementById('skillUpgradeTitle').textContent = `${item.name} 스킬 업그레이드 (Lv. ${item.level})`;
        document.getElementById('skillUpgradeDesc').textContent = '다음 중 하나를 선택하여 스킬을 강화하세요.';
        
        const optionsContainer = document.getElementById('skillUpgradeOptions');
        optionsContainer.innerHTML = '';
        
        optionsForLevel.forEach(option => {
            const button = document.createElement('button');
            button.className = 'button';
            button.style.width = '80%';
            button.style.padding = '15px';
            button.textContent = option.name;
            button.onclick = () => this.selectSkillUpgrade(option.id);
            optionsContainer.appendChild(button);
        });
        
        this.openModal('skillUpgradeModal');
    }

    selectSkillUpgrade(upgradeId) {
        if (this.activeSkillForUpgrade) {
            const itemInInventory = this.inventory.find(invItem => invItem.id === this.activeSkillForUpgrade.id);
            if (itemInInventory) {
                itemInInventory.upgrades.push(upgradeId);
                const upgradeMaster = SKILL_UPGRADE_DATA[itemInInventory.name];
                let chosenOption = null;
                Object.values(upgradeMaster).forEach(levelUpgrades => {
                    const opt = levelUpgrades.find(o => o.id === upgradeId);
                    if(opt) chosenOption = opt;
                });
                this.createNotification(`${itemInInventory.name} - ${chosenOption.name} 선택!`, 'success');
            }
        }
        
        this.closeModal('skillUpgradeModal');
        this.activeSkillForUpgrade = null;
        this.updateStats();
        this.resume();
    }
    
    updateUI(){
        const statMappings = { 'playerLevel': this.player.level, 'playerExp': Math.ceil(this.player.exp), 'expToNext': this.player.expToNext, 'playerHP': Math.ceil(this.player.hp), 'playerMaxHP': this.player.maxHp, 'playerAttack': this.player.attackPower, 'playerDefense': this.player.defense, 'playerCritRate': `${(this.player.critRate * 100).toFixed(0)}%`, 'playerGold': this.player.gold.toLocaleString(), 'gachaTokens': this.player.gachaTokens, 'playerPetCubes': this.player.petCubes, 'talentPoints': this.talentPoints, 'availableTalentPoints': this.talentPoints, 'advancementPoints': this.player.advancementPoints, 'playerJob': this.player.job || '없음', 'currentFloor': this.currentFloor, 'currentWave': this.currentWave, 'pityCounter': this.pityCounter };
        Object.entries(statMappings).forEach(([id, val]) => { const el = document.getElementById(id); if(el) el.textContent = val; });
        document.getElementById('hpBar').style.width = `${Math.max(0, this.player.hp / this.player.maxHp * 100)}%`; document.getElementById('expBar').style.width = `${this.player.exp / this.player.expToNext * 100}%`;
        const bS = this.equipment.weapon ? WEAPON_DATA[this.equipment.weapon.name].s : 1.2; let fS = bS * this.player.timeWarpMultiplier * (1 + this.player.attackSpeedBuff);
        if(this.talents['util1']) fS *= 1.1; if(this.talents['util6']) fS *= 1.15;
        if(this.talents['job_war2']) fS *= 0.9;
        document.getElementById('playerAttackSpeed').textContent = fS.toFixed(1);
        ['weapon', 'armor', 'pet'].forEach(type => {
            const i = this.equipment[type];
            const s = document.getElementById(`${type}Slot`);
            if (s) {
                if(i) {
                    const rD = RARITY_DATA[i.rarity];
                    s.innerHTML = `<div style="font-size: 11px; margin-top: 2px;"><span style="color:${rD.c}">(${i.rarity})</span> ${i.name}<br>Lv.${i.level}</div>`;
                    s.style.borderColor = rD.c;
                    s.classList.add('filled');
                } else {
                    const dT = { weapon: '맨손', armor: '없음', pet: '없음' };
                    s.innerHTML = `<div style="font-size: 11px; margin-top: 2px;">${dT[type]}</div>`;
                    s.style.borderColor = '#666';
                    s.classList.remove('filled');
                }
            }
        });
        this.equipment.skills.forEach((skill, index) => { const slot = document.getElementById(`skillSlot${index}`); if(skill) { slot.innerHTML = `<div style="font-size: 10px; margin-top: 2px;"><span style="color:${RARITY_DATA[skill.rarity].c}">(${skill.rarity})</span><br>${skill.name}</div><div class="cooldown-overlay"></div>`; slot.style.borderColor = RARITY_DATA[skill.rarity].c; slot.classList.add('filled'); const isReady = this.player.skillCooldowns[index] <= 0; slot.classList.toggle('skill-ready', isReady); const cO = slot.querySelector('.cooldown-overlay'); if(cO) { const cP = this.player.skillCooldowns[index] / (this.getModifiedSkillData(skill).cd * 1000) * 100; cO.style.height = `${Math.max(0, cP)}%`; } } else { slot.innerHTML = `<div class="cooldown-overlay"></div><div style="font-size: 9px;">빈 슬롯</div>`; slot.style.borderColor = '#666'; slot.classList.remove('filled', 'skill-ready'); const cO = slot.querySelector('.cooldown-overlay'); if(cO) cO.style.height = '0%'; } });
        this.equipment.jobSkills.forEach((skill, index) => {
            const slot = document.getElementById(`jobSkillSlot${index}`);
            if(skill) {
                slot.innerHTML = `<div style="font-size: 10px; margin-top: 2px;">${skill.name}</div><div class="cooldown-overlay"></div>`;
                slot.style.borderColor = '#e67e22';
                slot.classList.add('filled');
                const isReady = this.player.jobSkillCooldowns[index] <= 0;
                slot.classList.toggle('skill-ready', isReady);
                const cO = slot.querySelector('.cooldown-overlay');
                if(cO) {
                    const cP = this.player.jobSkillCooldowns[index] / (skill.cd * 1000) * 100;
                    cO.style.height = `${Math.max(0, cP)}%`;
                }
            } else {
                slot.innerHTML = `<div class="cooldown-overlay"></div><div style="font-size: 9px;">-</div>`;
                slot.style.borderColor = '#666';
                slot.classList.remove('filled', 'skill-ready');
                const cO = slot.querySelector('.cooldown-overlay'); if(cO) cO.style.height = '0%';
            }
        });
    }
    
    performGacha(count) { const cost = count === 1 ? 10 : 90; if(this.player.gachaTokens < cost) { this.createNotification('토큰이 부족합니다!', 'error'); return; } this.player.gachaTokens -= cost; const results = Array.from({ length: count }, () => this.rollGacha()); this.inventory.push(...results); this.showGachaResult(results); this.updateUI(); }
    showGachaResult(results) { const c = document.getElementById('gachaResultContent'); c.innerHTML = ''; results.forEach((i, idx) => { const card = document.createElement('div'); card.className = 'gacha-card'; const inner = document.createElement('div'); inner.className = 'gacha-card-inner'; const front = document.createElement('div'); front.className = 'gacha-card-front'; front.innerHTML = '<div>?</div>'; const back = document.createElement('div'); back.className = 'gacha-card-back'; const rD = RARITY_DATA[i.rarity]; back.style.background = `radial-gradient(ellipse at center, ${rD.c} 0%, #000 100%)`; back.style.color = i.rarity === 'G' ? '#000' : '#fff'; back.innerHTML = `<strong style="color:${rD.c}; text-shadow: 0 0 15px ${rD.c}; font-size: 14px;">${i.rarity}</strong><div style="margin: 8px 0; font-size: 12px; font-weight: bold;">${i.name}</div>${i.special ? `<div style="color: gold; font-size: 10px; margin-top: 5px;">${i.special}</div>` : ''}`; inner.appendChild(front); inner.appendChild(back); card.appendChild(inner); c.appendChild(card); setTimeout(() => { card.classList.add('is-flipped'); const rI = Object.keys(RARITY_DATA).indexOf(i.rarity); if(rI >= 4) { for(let j = 0; j < 30 + rI * 10; j++) { this.particles.push(new Particle(this.canvas.width/2, this.canvas.height/2, rD.c, Math.random() * 6 + 2, 200 + rI * 50, 1000 + rI * 200)); } if(rI >= 6) this.createNotification(`${i.rarity} 등급 ${i.name} 획득!`, 'success'); } }, 150 + idx * 200); }); }
    
    performPetGacha(count) {
        const cost = 5 * count;
        if (this.player.petCubes < cost) {
            this.createNotification('펫 큐브가 부족합니다!', 'error');
            return;
        }
        this.player.petCubes -= cost;

        const results = Array.from({ length: count }, () => {
            let rand = Math.random(), cum = 0, rarity = 'N';
            for (const [key, data] of Object.entries(RARITY_DATA)) {
                cum += data.r;
                if (rand < cum) { rarity = key; break; }
            }
            const petNames = Object.keys(PET_DATA);
            const name = petNames[Math.floor(Math.random() * petNames.length)];
            return { id: `${Date.now()}${Math.random()}`, name, rarity, level: 1, exp: 0, expToNext: 20, type: 'pet' };
        });

        this.pets.push(...results);
        this.showGachaResult(results); 
        this.updateUI();
        this.updatePetPanelDisplay();
    }
    
    initTalentTree() {
        const advContainer = document.getElementById('job-advancement-container');
        const talentContainer = document.getElementById('talent-container');
        talentContainer.innerHTML = '';
        
        if (this.player.advancementPoints > 0 && !this.player.job) {
            advContainer.style.display = 'block';
            document.getElementById('availableAdvancementPoints').textContent = this.player.advancementPoints;
            const buttonsContainer = document.getElementById('job-selection-buttons');
            buttonsContainer.innerHTML = '';
            
            Object.values(TALENT_DATA).filter(c => c.job).forEach(jobCat => {
                const btn = document.createElement('button');
                btn.className = 'button';
                btn.textContent = `${jobCat.name}로 전직`;
                btn.onclick = () => this.selectJob(jobCat.name);
                buttonsContainer.appendChild(btn);
            });

        } else {
            advContainer.style.display = 'none';
        }

        for (const cId in TALENT_DATA) { 
            const cat = TALENT_DATA[cId];
            if (cat.job && this.player.job !== cat.name) continue;

            const tD = document.createElement('div');
            tD.className = 'talent-tree'; 
            const nD = document.createElement('div'); 
            nD.className = 'talent-tree-name'; 
            nD.textContent = cat.name; 
            if(cat.job) nD.style.color = '#e67e22';
            tD.appendChild(nD); 
            const nodesContainer = document.createElement('div'); 
            nodesContainer.className = 'talent-nodes-container'; 
            cat.talents.forEach((t, idx) => { const w = document.createElement('div'); w.className = 'talent-node-wrapper'; const node = document.createElement('div'); node.className = 'talent-node'; node.innerHTML = `<div class="talent-node-name">${t.name}</div><div class="talent-node-desc">${t.desc}</div><div class="talent-node-cost">비용: ${t.cost}</div>`; const iU = this.talents[t.id]; const cU = this.canUnlockTalent(t); if (iU) node.classList.add('unlocked'); else if (cU) { node.classList.add('available'); node.addEventListener('click', () => this.unlockTalent(t)); } w.appendChild(node); if(idx < cat.talents.length - 1) { const conn = document.createElement('div'); conn.className = 'talent-connector'; w.appendChild(conn); } nodesContainer.appendChild(w); }); tD.appendChild(nodesContainer); talentContainer.appendChild(tD); 
        } 
    }
    canUnlockTalent(t) { if (this.talents[t.id]) return false; if (this.talentPoints < t.cost) return false; if (t.prereq && !this.talents[t.prereq]) return false; return true; }
    unlockTalent(t) { if (!this.canUnlockTalent(t)) return; this.talentPoints -= t.cost; this.talents[t.id] = true; this.createNotification(`${t.name} 특성을 획득했습니다!`, 'success'); this.updateStats(); this.initTalentTree(); }
    createNotification(m, t = 'info') { const a = document.getElementById('notification-area'); const n = document.createElement('div'); n.className = 'notification'; n.textContent = m; const c = { success: '#2ecc71', error: '#e74c3c', warning: '#f1c40f', info: '#3498db' }; n.style.borderColor = c[t] || c.info; n.style.backgroundColor = (c[t] || c.info).replace(')', ', 0.9)').replace('rgb', 'rgba'); a.appendChild(n); setTimeout(() => { if(n.parentNode) n.parentNode.removeChild(n); }, 4000); }
    equipItem(i) {
        if (this.isSelectingForSynth) {
            this.addItemToSynthSlot(i);
            return;
        }
        if (i.type === 'pet') {
             this.equipPet(i);
             return;
        }
        if (this.skillEquipSlot !== -1 && i.type === 'skill') {
             this.equipSkill(i);
             return;
        }
        if(i.type === 'weapon') this.equipment.weapon = i;
        else if(i.type === 'armor') this.equipment.armor = i;
        this.updateStats(); this.updateInventoryDisplay(); this.createNotification(`${i.name} 장착 완료!`, 'success');
    }
    filterInventory(f) { this.inventoryFilter = f; this.updateInventoryDisplay(); }
    createFloatingText(t, x, y, c = '255,255,255', s = 20) { this.floatingTexts.push({ text:t, x, y, c, s, alpha: 1, life: 2000 }); }
    openModal(id) { document.getElementById('modal-backdrop').style.display = 'flex'; document.getElementById(id).style.display = 'block'; }
    closeModal(id) { document.getElementById('modal-backdrop').style.display = 'none'; document.getElementById(id).style.display = 'none'; }
    gameOver() { this.isGameOver = true; document.getElementById('finalFloor').textContent = this.currentFloor; this.openModal('gameOverScreen'); this.pause(); localStorage.removeItem('hackSlashGame_v25'); }
    spawnWave() { const eC = Math.min(3 + Math.floor(this.currentFloor * 1.5), 15); const elC = Math.min(0.1 + (this.currentFloor * 0.05), 0.4); for(let i = 0; i < eC; i++) { this.enemies.push(new Enemy(this, Math.random() < elC)); } }
    completeFloor() { this.floorCompleted = true; let gR = Math.floor(150 * this.currentFloor * (1 + this.currentFloor * 0.1)); let tR = Math.floor(8 * this.currentFloor + (this.currentFloor > 10 ? this.currentFloor * 2 : 0)); if (this.talents['greed8']) { gR = Math.floor(gR * 1.2); tR = Math.floor(tR * 1.2); } this.player.gold += gR; this.player.gachaTokens += tR; this.player.petCubes += Math.floor(1 + this.currentFloor / 5); let bH = ''; if(this.currentFloor % 10 === 0) { const bT = this.currentFloor * 10; this.player.gachaTokens += bT; bH = `<div style="color: #f1c40f; font-weight: bold;">10층 돌파 보너스! 토큰 +${bT}</div>`; this.createNotification(`${this.currentFloor}층 달성 보너스! +${bT} 토큰!`, 'success'); } document.getElementById('floorReward').innerHTML = `<h2>${this.currentFloor}층 클리어!</h2><p>골드 +${gR.toLocaleString()}</p><p>토큰 +${tR}</p>${bH}`; this.openModal('floorInfo'); this.pause(); }
    nextFloor() { this.currentFloor++; this.currentWave = 1; this.floorCompleted = false; this.closeModal('floorInfo'); this.spawnWave(); this.resume(); }
    updateInventoryDisplay() { const list = document.getElementById('inventoryList'); list.innerHTML = ''; const filtered = this.inventory.filter(i => this.inventoryFilter === 'all' || i.type === this.inventoryFilter); filtered.sort((a, b) => Object.keys(RARITY_DATA).indexOf(b.rarity) - Object.keys(RARITY_DATA).indexOf(a.rarity)); filtered.forEach(item => { const div = document.createElement('div'); div.className = `item ${item.rarity}`; const rC = RARITY_DATA[item.rarity].c; div.style.borderLeftColor = rC; div.onclick = () => this.equipItem(item); if(Object.values(this.equipment).flat().some(e => e?.id === item.id)) div.classList.add('equipped'); let cost = Math.floor(150 * Math.pow(2.3, item.level)); if (this.talents['greed5']) cost = Math.floor(cost * 0.8); const iD = document.createElement('div');
            if(item.type === 'skill'){
                const expPercent = (item.exp / item.expToNext) * 100;
                const expBar = `<div class="progress-bar" style="height: 8px; margin: 4px 0;"><div class="progress-fill" style="background: var(--primary-color); width: ${expPercent}%;"></div></div>`;
                iD.innerHTML = `<div style="width: 100%;"><strong style="color:${rC}">(${item.rarity}) ${item.name} (Lv.${item.level})</strong><br><small>경험치: ${item.exp} / ${item.expToNext}</small>${expBar}</div>`;
                div.appendChild(iD);
            } else {
                let starDisplay = '';
                if (item.star > 0) {
                    starDisplay = ' ' + '★'.repeat(item.star);
                }
                iD.innerHTML = `<div style="display:flex;align-items:center;gap:10px; flex-grow: 1;"><div><strong style="color:${rC}">(${item.rarity}) ${item.name} (+${item.level})${starDisplay}</strong><br><small>능력치: ${item.power}${item.special?' | '+item.special:''}</small></div></div>`;
                const btnContainer = document.createElement('div');
                btnContainer.style.display = 'flex';
                btnContainer.style.gap = '5px';
                
                const eB = document.createElement('button');
                eB.className = 'button';
                eB.textContent = `강화 (${cost.toLocaleString()}G)`;
                eB.disabled = item.level >= 10 || this.player.gold < cost;
                eB.onclick = (e) => { e.stopPropagation(); this.enhanceItem(item.id); };

                const pB = document.createElement('button');
                pB.className = 'button';
                pB.style.backgroundColor = '#9b59b6';
                pB.textContent = `초월`;
                const duplicate = this.inventory.find(invItem => invItem.id !== item.id && invItem.name === item.name && invItem.rarity === item.rarity);
                pB.disabled = !duplicate || (item.star || 0) >= 5;
                pB.onclick = (e) => { e.stopPropagation(); this.promoteItem(item.id); };

                div.appendChild(iD);
                btnContainer.appendChild(eB);
                btnContainer.appendChild(pB);
                div.appendChild(btnContainer);
            }
            list.appendChild(div); }); }
    openView(panelId, filter) {
        if (!this.openPanels.includes(panelId)) this.openPanels.push(panelId);
        document.getElementById(panelId).style.display = 'block'; 
        this.pause(); 
        if(panelId === 'inventoryPanel') {
             if (!this.isSelectingForSynth) {
                this.filterInventory(filter || 'all');
            } else {
                this.updateInventoryDisplay();
            }
        } else if(panelId === 'talentPanel') {
            this.initTalentTree(); 
        } else if (panelId === 'petPanel') { 
            this.updatePetPanelDisplay(); 
        } else if (panelId === 'synthesisPanel') {
            this.synthesisSlots = [null, null, null];
            this.updateSynthesisPanel();
        }
    }
    closeView(panelId) { 
        document.getElementById(panelId).style.display = 'none'; 
        this.openPanels = this.openPanels.filter(p => p !== panelId);

        if (this.openPanels.length === 0) {
            this.resume(); 
        }
        
        if(panelId === 'inventoryPanel') { 
            this.skillEquipSlot = -1;
            if (this.isSelectingForSynth) {
                this.isSelectingForSynth = false;
            }
        } 
    }
    saveGame() { const data = { p: this.player, e: this.equipment, i: this.inventory, f: this.currentFloor, w: this.currentWave, c: this.pityCounter, t: this.talents, tp: this.talentPoints, pets: this.pets, ap: this.player.advancementPoints, job: this.player.job }; localStorage.setItem('hackSlashGame_v25', JSON.stringify(data)); }
    loadGame() {
        const data = localStorage.getItem('hackSlashGame_v25');
        if(data) {
            try {
                const s = JSON.parse(data);
                if (s.p) Object.assign(this.player, s.p);

                // Sanitize inventory data
                if (s.i) {
                    this.inventory = s.i.filter(item => {
                        if (!item || !item.type || !item.name) return false;
                        switch (item.type) {
                            case 'weapon': return WEAPON_DATA[item.name];
                            case 'armor':  return ARMOR_DATA[item.name];
                            case 'skill':  return SKILL_DATA[item.name];
                            case 'pet':    return PET_DATA[item.name];
                            default:       return false;
                        }
                    });
                     this.inventory.forEach(item => { if ((item.type === 'weapon' || item.type === 'armor') && item.star === undefined) { item.star = 0; } });
                }

                // Sanitize equipment data
                if (s.e) { 
                    this.equipment = s.e;
                    if (this.equipment.weapon && !WEAPON_DATA[this.equipment.weapon.name]) {
                        this.equipment.weapon = null;
                    }
                    if (this.equipment.armor && !ARMOR_DATA[this.equipment.armor.name]) {
                        this.equipment.armor = null;
                    }
                    if (this.equipment.skills) {
                        this.equipment.skills = this.equipment.skills.map(skill => 
                            (skill && SKILL_DATA[skill.name]) ? skill : null
                        );
                    } else {
                        this.equipment.skills = [null, null, null, null];
                    }
                     if (this.equipment.pet && PET_DATA[this.equipment.pet.name]) {
                        this.activePet = new Pet(this, this.equipment.pet);
                    } else {
                        this.equipment.pet = null;
                    }
                } else {
                     this.equipment = {weapon: null, armor: null, skills: [null, null, null, null], pet: null, jobSkills: [null, null]}; 
                }
                
                if (s.t) this.talents = s.t;
                this.currentFloor = s.f || 1;
                this.currentWave = s.w || 1;
                this.pityCounter = s.c || 100;
                this.talentPoints = s.tp || 0;
                this.pets = (s.pets || []).filter(pet => pet && PET_DATA[pet.name]);
                this.player.advancementPoints = s.ap || 0;
                this.player.job = s.job || null;
                
                // Set job skills after loading job
                if(this.player.job && JOB_SKILL_DATA[this.player.job]) {
                    this.equipment.jobSkills = JOB_SKILL_DATA[this.player.job];
                } else {
                    this.equipment.jobSkills = [null, null];
                }
                
            } catch(e) {
                console.error("Save Load Failed, resetting:", e);
                localStorage.removeItem('hackSlashGame_v25');
                this.resetPlayerState();
            }
        }
    }
    findClosestEnemy(x, y) {
        let closest = null;
        let minDistance = Infinity;
        this.enemies.forEach(enemy => {
            const distance = Math.hypot(x - enemy.x, y - enemy.y);
            if (distance < minDistance) {
                minDistance = distance;
                closest = enemy;
            }
        });
        return closest;
    }

    gainPetExp(amount) {
        const activePetItem = this.equipment.pet;
        if (!activePetItem) return;

        const petInList = this.pets.find(p => p.id === activePetItem.id);
        if (!petInList) return;

        petInList.exp += amount;
        
        if (petInList.exp >= petInList.expToNext) {
            this.petLevelUp(petInList);
        }
        
        if (document.getElementById('petPanel').style.display === 'block') {
            this.updatePetPanelDisplay();
        }
        this.updateUI();
    }

    petLevelUp(petItem) {
        petItem.level++;
        petItem.exp -= petItem.expToNext;
        petItem.expToNext = Math.floor(20 * Math.pow(1.6, petItem.level - 1));
        this.createNotification(`${petItem.name} 펫 레벨 업! (Lv.${petItem.level})`, 'success');
    }

    equipPet(petItem) {
        if (this.equipment.pet && this.equipment.pet.id === petItem.id) {
            this.equipment.pet = null;
            this.activePet = null;
            this.createNotification(`${petItem.name} 펫을 장착 해제했습니다.`, 'info');
        } else {
            this.equipment.pet = petItem;
            this.activePet = new Pet(this, petItem);
            this.createNotification(`${petItem.name} 펫을 장착했습니다.`, 'success');
        }
        if (document.getElementById('petPanel').style.display === 'block') {
            this.updatePetPanelDisplay();
        }
        this.updateUI();
    }
    
    updatePetPanelDisplay() {
        const list = document.getElementById('petList');
        list.innerHTML = '';
        const sortedPets = [...(this.pets || [])].sort((a, b) => {
            const rarityA = Object.keys(RARITY_DATA).indexOf(a.rarity);
            const rarityB = Object.keys(RARITY_DATA).indexOf(b.rarity);
            return rarityB - rarityA;
        });
        sortedPets.forEach(pet => {
            const div = document.createElement('div');
            div.className = 'item';
            const rC = RARITY_DATA[pet.rarity].c;
            div.style.borderLeftColor = rC;
            div.onclick = () => this.equipPet(pet);
            const isEquipped = this.equipment.pet && this.equipment.pet.id === pet.id;
            if(isEquipped) {
                div.classList.add('equipped');
            }
            const iD = document.createElement('div');
            iD.style.width = '100%';
            const expPercent = pet.expToNext > 0 ? (pet.exp / pet.expToNext) * 100 : 0;
            const expBar = `<div class="progress-bar" style="height: 8px; margin: 4px 0;"><div class="progress-fill" style="background: var(--primary-color); width: ${expPercent}%;"></div></div>`;
            iD.innerHTML = `<strong style="color:${rC}">(${pet.rarity}) ${pet.name} (Lv.${pet.level})</strong><br>
                              <small>경험치: ${pet.exp} / ${pet.expToNext}</small>
                              ${expBar}`;
            const equipButton = document.createElement('button');
            equipButton.className = 'button';
            equipButton.textContent = isEquipped ? '해제' : '장착';
            equipButton.style.flexShrink = '0';
            equipButton.onclick = (e) => {
                e.stopPropagation();
                this.equipPet(pet);
            };
            div.appendChild(iD);
            div.appendChild(equipButton);
            list.appendChild(div);
        });
    }

    getAttackSpeed() {
        const wI = this.equipment.weapon || {name: '맨손', rarity: 'N'};
        const w = WEAPON_DATA[wI.name];
        let speed = w.s;

        // 버프: 시간 왜곡 스킬
        speed *= this.player.timeWarpMultiplier;
        
        // 버프: 위습 펫
        speed *= (1 + this.player.attackSpeedBuff);
        
        // 특성
        if(this.talents['util1']) speed *= 1.1;
        if(this.talents['util6']) speed *= 1.15;
        if(this.talents['job_war2']) speed *= 0.9;

        // 스킬 업그레이드 효과: 광폭화 (피의 계약)
        if (this.player.rageDuration > 0) {
            const rageSkill = this.equipment.skills.find(s => s && s.name === '광폭화');
            if (rageSkill) {
                const modifiedSkillData = this.getModifiedSkillData(rageSkill);
                if (modifiedSkillData.blood_pact) {
                    speed *= modifiedSkillData.blood_pact.as_inc;
                }
            }
        }
        
        // 스킬 업그레이드 효과: 피의 갈증 (광란)
        const bloodThirstEffect = this.activeEffects.find(e => e.s && e.s.type === 'blood_thirst');
        if(bloodThirstEffect && bloodThirstEffect.s.frenzy) {
            speed *= bloodThirstEffect.s.frenzy;
        }

        return speed;
    }

    selectSynthItem(slotIndex) {
        if (this.synthesisSlots[slotIndex]) {
            this.synthesisSlots[slotIndex] = null;
            this.updateSynthesisPanel();
        } else {
            this.synthSelectionSlot = slotIndex;
            this.isSelectingForSynth = true;
            this.openView('inventoryPanel');
            this.createNotification('합성에 사용할 아이템을 선택하세요.', 'info');
        }
    }

    addItemToSynthSlot(item) {
        if (item.type !== 'weapon' && item.type !== 'armor') {
            this.createNotification('무기 또는 방어구만 합성할 수 있습니다.', 'error');
            this.isSelectingForSynth = false; this.closeView('inventoryPanel');
            return;
        }
        if (this.synthesisSlots.some(i => i && i.id === item.id)) {
            this.createNotification('이미 등록된 아이템입니다.', 'error');
            this.isSelectingForSynth = false; this.closeView('inventoryPanel');
            return;
        }

        this.synthesisSlots[this.synthSelectionSlot] = item;
        this.isSelectingForSynth = false;
        this.synthSelectionSlot = -1;
        this.closeView('inventoryPanel');
        this.updateSynthesisPanel();
    }

    updateSynthesisPanel() {
        const slots = document.querySelectorAll('.synthesis-slot');
        let cost = 0;
        let chance = 0;
        let canSynthesize = false;

        slots.forEach((slot, index) => {
            const item = this.synthesisSlots[index];
            if (item) {
                const rD = RARITY_DATA[item.rarity];
                slot.innerHTML = `<div style="font-size: 11px; margin-top: 2px; pointer-events:none;"><span style="color:${rD.c}">(${item.rarity})</span> ${item.name}</div>`;
                slot.style.borderColor = rD.c;
                slot.classList.add('filled');
            } else {
                slot.innerHTML = '';
                slot.style.borderColor = '#666';
                slot.classList.remove('filled');
            }
        });

        const items = this.synthesisSlots.filter(i => i !== null);
        if (items.length === 3) {
            const firstItem = items[0];
            const isSameType = items.every(i => i.type === firstItem.type);
            const isSameRarity = items.every(i => i.rarity === firstItem.rarity);

            if (isSameType && isSameRarity) {
                const rarityIndex = Object.keys(RARITY_DATA).indexOf(firstItem.rarity);
                if (rarityIndex < Object.keys(RARITY_DATA).length - 1) {
                    cost = Math.floor(1000 * Math.pow(3, rarityIndex));
                    chance = Math.max(10, 90 - rarityIndex * 8);
                    canSynthesize = true;
                } else {
                    this.createNotification('최고 등급 아이템은 합성할 수 없습니다.', 'warning');
                }
            } else {
                this.createNotification('동일한 종류와 등급의 아이템 3개를 사용해야 합니다.', 'warning');
            }
        }

        document.getElementById('synthesisCost').textContent = cost.toLocaleString();
        document.getElementById('synthesisChance').textContent = chance;
        document.getElementById('synthesizeButton').disabled = !canSynthesize || this.player.gold < cost;
    }

    synthesizeItems() {
        const items = this.synthesisSlots.filter(i => i !== null);
        if (items.length !== 3) return;

        const firstItem = items[0];
        const rarityIndex = Object.keys(RARITY_DATA).indexOf(firstItem.rarity);
        const cost = Math.floor(1000 * Math.pow(3, rarityIndex));
        const chance = Math.max(10, 90 - rarityIndex * 8) / 100;

        if (this.player.gold < cost) {
            this.createNotification('골드가 부족합니다.', 'error');
            return;
        }

        this.player.gold -= cost;
        this.inventory = this.inventory.filter(invItem => !items.some(slotItem => slotItem.id === invItem.id));

        if (Math.random() < chance) {
            const rarities = Object.keys(RARITY_DATA);
            const nextRarity = rarities[rarityIndex + 1];
            
            let newItemPool = [];
            if (firstItem.type === 'weapon') newItemPool = Object.keys(WEAPON_DATA).filter(n => n !== '맨손');
            else if (firstItem.type === 'armor') newItemPool = Object.keys(ARMOR_DATA);
            
            const name = newItemPool[Math.floor(Math.random() * newItemPool.length)];
            const newItem = { id: `${Date.now()}${Math.random()}`, name: name, type: firstItem.type, rarity: nextRarity, level: 0, star: 0, power: Math.floor(5 * RARITY_DATA[nextRarity].p) };
            
            this.inventory.push(newItem);
            this.createNotification(`합성 성공! (${nextRarity}) ${newItem.name} 획득!`, 'success');

        } else {
            this.createNotification('합성에 실패했습니다...', 'error');
        }
        
        this.synthesisSlots = [null, null, null];
        this.updateSynthesisPanel();
        this.updateUI();
        this.updateInventoryDisplay();
    }

    promoteItem(targetId) {
        const targetItem = this.inventory.find(i => i.id === targetId);
        if (!targetItem) return;

        const materialItem = this.inventory.find(i => i.id !== targetId && i.name === targetItem.name && i.rarity === targetItem.rarity);
        if (!materialItem) {
            this.createNotification('초월에 필요한 동일한 아이템이 없습니다.', 'error');
            return;
        }
        
        const star = targetItem.star || 0;
        if (star >= 5) {
            this.createNotification('최대 성급에 도달했습니다.', 'error');
            return;
        }

        const cost = Math.floor(2000 * Math.pow(4, star) * (Object.keys(RARITY_DATA).indexOf(targetItem.rarity) + 1));
        if (this.player.gold < cost) {
            this.createNotification(`골드가 부족합니다. (필요: ${cost.toLocaleString()}G)`, 'error');
            return;
        }

        this.player.gold -= cost;
        targetItem.star = star + 1;
        this.inventory = this.inventory.filter(i => i.id !== materialItem.id);

        this.createNotification(`${targetItem.name} 초월 성공! (${'★'.repeat(targetItem.star)})`, 'success');
        
        this.updateStats();
        this.updateInventoryDisplay();
    }

    selectJob(jobName) {
        if (this.player.advancementPoints > 0 && !this.player.job) {
            this.player.job = jobName;
            this.player.advancementPoints--;
            this.createNotification(`${jobName}으로 전직했습니다!`, 'success');
            if (JOB_SKILL_DATA[jobName]) {
                this.equipment.jobSkills = JOB_SKILL_DATA[jobName];
            }
            this.initTalentTree();
            this.updateUI();
        }
    }
}

const PET_DATA = {
    '새끼용': { type: 'attack', power: 0.8, interval: 2500, projectile: { speed: 15, color: '#e74c3c', shape: 'fireball' }, shape: 'dragon', color: '#e74c3c' },
    '요정': { type: 'heal', power: 0.05, interval: 5000, condition: (p) => p.hp / p.maxHp < 0.7, shape: 'fairy', color: '#ff9ff3' },
    '골렘': { type: 'tank', power: 0.2, interval: 8000, shape: 'golem', color: '#7f8c8d' },
    '위습': { type: 'buff', power: 0.15, interval: 10000, duration: 5000, buff: 'attackSpeed', shape: 'wisp', color: '#f1c40f' },
    '유령': { type: 'debuff', power: 0.1, interval: 6000, radius: 150, debuff: 'slow', shape: 'ghost', color: '#ecf0f1' }
};

class Pet {
    constructor(game, petItem) {
        this.game = game;
        this.item = petItem;
        this.data = PET_DATA[petItem.name];
        this.x = game.player.x - 50;
        this.y = game.player.y;
        this.lastActionTime = 0;
    }

    update(dt) {
        // Player following
        const targetX = this.game.player.x - 50;
        const targetY = this.game.player.y;
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        this.x += dx * 0.05;
        this.y += dy * 0.05;

        // Action
        if (Date.now() - this.lastActionTime > this.data.interval) {
            this.performAction();
            this.lastActionTime = Date.now();
        }
    }

    performAction() {
        const p = this.game.player;
        const power = this.data.power * (1 + (this.item.level - 1) * 0.1);

        switch (this.data.type) {
            case 'attack':
                const target = this.game.findClosestEnemy(this.x, this.y);
                if (target) {
                    const angle = Math.atan2(target.y - this.y, target.x - this.x);
                    const vx = Math.cos(angle) * this.data.projectile.speed * 30;
                    const vy = Math.sin(angle) * this.data.projectile.speed * 30;
                    const fakeItem = { name: this.item.name, rarity: this.item.rarity };
                    const weaponData = {
                        life: 1000,
                        p: false,
                        d: power,
                        e: { shape: this.data.projectile.shape || 'fireball' }
                    };
                    const damage = this.game.player.attackPower * power;
                    this.game.projectiles.push(new Projectile(this.game, 'pet', fakeItem, this.x, this.y, vx, vy, weaponData, damage));
                }
                break;
            case 'heal':
                if (this.data.condition(p)) {
                    const healAmount = p.maxHp * power;
                    p.hp = Math.min(p.maxHp, p.hp + healAmount);
                    this.game.createFloatingText(`+${Math.ceil(healAmount)}`, p.x, p.y - 30, '#2ecc71', 18);
                }
                break;
            case 'tank':
                this.game.createFloatingText('방벽!', this.x, this.y - 20, '#7f8c8d', 20);
                this.game.enemies.forEach(e => {
                    if (Math.hypot(this.x - e.x, this.y - e.y) < 150) {
                        e.applyStatusEffect(STATUS_EFFECTS.STUN, 1500);
                    }
                });
                break;
            case 'buff':
                this.game.createFloatingText('가속!', p.x, p.y - 30, '#f1c40f', 18);
                p.attackSpeedBuff = power;
                p.attackSpeedBuffDuration = this.data.duration;
                break;
            case 'debuff':
                this.game.enemies.forEach(e => {
                    if (Math.hypot(this.x - e.x, this.y - e.y) < this.data.radius) {
                        e.applyStatusEffect(STATUS_EFFECTS.SLOW, 3000, 0, power);
                    }
                });
                break;
        }
         this.game.gainPetExp(1);
    }

    draw(ctx) {
        ctx.save();
        drawPetShapes(ctx, this.data.shape, this.x, this.y, 1, this.data.color);
        ctx.restore();
    }
}

window.onload = () => { window.game = new Game(); };        
</script>
</body>
</html>
